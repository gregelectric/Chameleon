;;*****************************************************************************
;;*****************************************************************************
;;  FILENAME: USB_Bt_loader.asm
;;  Version: 1.50, Updated on 2011/6/28 at 6:8:6
;;  Generated by PSoC Designer 5.4.2946
;;
;;  DESCRIPTION: USB User Module Descriptors
;;
;;  NOTE: User Module APIs conform to the fastcall convention for marshalling
;;        arguments and observe the associated "Registers are volatile" policy.
;;        This means it is the caller's responsibility to preserve any values
;;        in the X and A registers that are still needed after the API
;;        function returns. Even though these registers may be preserved now,
;;        there is no guarantee they will be preserved in future releases.
;;-----------------------------------------------------------------------------
;;  Copyright (c) Cypress Semiconductor 2011. All Rights Reserved.
;;*****************************************************************************
;;*****************************************************************************
;*******************************************************************
;
;                   U S B   B O O T L O A D E R
;
;
; Writen By:   Ganesh
; Modified By: BRW/ KVN
; Purpose:     Bootloader flash download and write routines
; Completed:   12/18/2006
; Description: This Bootloader is modified to be included in a two
;              Device usb configuration.  Both usb devices share the
;              same flash space that is protected in this bootloader
;              area. The Bootloader USB device is started by starting 
;              Device 0xff.
;              Bootloader RAM is reallocated at the beginning of bootloader
;              operation.  Other memory organization may be done 'around' 
;              bootloader required areas.  Bootloader memory also uses
;              ram locations in the lowest area of page 0.  Stack area is
;              maintained on page 3. 
;
;*******************************************************************


;*******************************************************************************
;*** INCLUDES ******************************************************************
;*******************************************************************************
include "m8c.inc"       
include "memory.inc"
include "USB_bt_loader.inc"
include "USB.inc"
include "USB_Flash.inc"
include "globalparams.inc"


;*******************************************************************************
;*** EXPORTS *******************************************************************
;*******************************************************************************
export bootLoaderVerify

export bootRamBuffer
export bootByteCount
export bootRecordChecksum
export bootSourcePointer
export bootCommand
export bootTimeoutDelay
export bootFlashChecksum
export bootRomAddress
export bootBlockCount
export bootErrorCode
export bootFlag
export bootFlashFlag 
export bootBlockId
export bootNoOfBlocks
export bootEnteredFromUserCode
export bootDestPointer

export  USB_EnterBootloader
export _USB_EnterBootloader
export  GenericBootloaderEntry
export _GenericBootloaderEntry


;*******************************************************************************
;*** EQUATE VARIABLES **********************************************************
;*******************************************************************************
BOOT_VARIABLES::                EQU     0x0180

bootRamBuffer::                 EQU     BOOT_VARIABLES + 0        ; Buffer in RAM to store received data 
bootByteCount::                 EQU     BOOT_VARIABLES + 66   ;1c2; Byte counter
bootRecordChecksum::            EQU     BOOT_VARIABLES + 67   ;1c3; Stores the calculated checksum of the received record
bootSourcePointer::             EQU     BOOT_VARIABLES + 68	  ;1c4
bootCommand::                   EQU     BOOT_VARIABLES + 69   ;1c5; Stores the received command
bootTimeoutDelay::              EQU     BOOT_VARIABLES + 70	  ;1c6
bootFlashChecksum::             EQU     BOOT_VARIABLES + 74   ;1ca; 2 byte checksum of the Flash memory from Block 1 to Block 223
bootRomAddress::                EQU     BOOT_VARIABLES + 76   ;1cc; Address of Flash memory
bootBlockCount::                EQU     BOOT_VARIABLES + 78   ;1ce; & FD Block Counter
bootErrorCodePrefix::           EQU     BOOT_VARIABLES + 80	  ;1d0
bootErrorCode::                 EQU     BOOT_VARIABLES + 81	  ;1d1
bootFlag::                      EQU     BOOT_VARIABLES + 82	  ;1d2
bootFlashFlag::                 EQU     BOOT_VARIABLES + 83   ;1d3; Variable that indicates if the received data is the 1st 
bootBlockId::                   EQU     BOOT_VARIABLES + 84   ;1d4; Current Block Count
bootNoOfBlocks::                EQU     BOOT_VARIABLES + 86   ;1d6; Has the number of blocks to be written to Flash
bootEnteredFromUserCode::       EQU     BOOT_VARIABLES + 87   ;1d7; 
bootDestPointer::               EQU     BOOT_VARIABLES + 90	  ;1da

	; bootErrorCode Bit Flags Definitions

        ; 7 6 5 4 3 2 1 0 
	; | | | | | | | |__ Boot Completed Successfully
	; | | | | | | |____ Image Verify Error
	; | | | | | |______ Flash Checksum  Error
	; | | | | |________ Flash Protection Error
	; | | | |__________ Command / Packet Checksum Error
	; | | |____________ Bootload Mode entered
	; | |______________ Invalid Bootload Key received
	; |________________ Invalid Command received
	

BootSignature::                 EQU     0x00F3     ; RAM location where the 4 byte boot signature is stored
bootFlashBuffer0::              EQU     0x0100     ; Buffer that stores the 64 byte Flash data
bootFlashBuffer1::              EQU     0x0140     ; Buffer used to read a Flash block for
                                                   ; Flash write verify

;*******************************************************************************
;*** VARIABLES *****************************************************************
;*******************************************************************************
; These 2 variables are used to monitor the activity of the EP1 and EP2 endpoints
; As these variables will be accessed inside the EP1 and EP2 ISRs, they are located
; in page 0

area BootloaderRAM(RAM, REL, CON)
_bEp1Count::       
 bEp1Count::        BLK   	1

_bEp2Count::       
 bEp2Count::        BLK   	1

 LbResetISR::       BLK 	1




;*******************************************************************************
;*** CHECKSUM BLOCK *********************************************************
;*******************************************************************************
;****************************************************************************************
; declaration of application start blocks (used for later checksum calculation)
; by definition, to allow the app to be upgradable this data must be a variable in a 
; permanently fixed location (like the CheckSumBlock).  
; It cannot be an equate or something like that, since that doesn't compile to a ROM location.
;----------------------------------------------------------------------------------------

USB_AppStartAddr: equ (56h << 6)
USB_AppEndAddr: equ (fdh	<< 6)
ApplicationSize: equ 	(fdh - 56h + 1h)
NUMBER_OF_BLOCKS: equ ApplicationSize

;****************************************************************************************
; declaration of a block to store checksum information.  Specified in UM parameters
;----------------------------------------------------------------------------------------
AREA  BLChecksum (ROM, REL)


;it's OK to store this ChecksumBlock address as an equate since once defined it can't move   
;somewhwere else without rebuilding and recompiling the bootloader
USB_CheckSumBlock: equ  (ffh << 6)
USB_CheckSumAddr:  equ  (ffh << 6) 
USB_MAXMEM:        equ	  0x3fff

export  _USB_pAppChkSumBlk
export   USB_pAppChkSumBlk
_USB_pAppChkSumBlk:
 USB_pAppChkSumBlk:

CHK_DEFAULTS: equ (USB_CheckSumBlock & ~(USB_MAXMEM))
IF(CHK_DEFAULTS)
Parameter error detection:  Instructions for correcting this error are below.
Instructions:
Verify that the block addresses for the Checksum block and the Last application block do not exceet the defined size of the 
part selected for this project.  For some devices the default value is larger than the available flash for the device.
Once the problem has been corrected, open the bootloader tools and click on the button to regenerate the application with a
valid checksum.  Data for this error check will be automatically re-generated and the compile error will be gone.

ENDIF


USB_CheckSumBlockCksum: 
DW e95h	 ; first two locations in block
USB_RelocVectors:
DW (53h << 6)
USB_AppStart:
DW (56h << 6)
USB_AppEnd:
DW (fdh	<< 6)
USB_AppSize:
DW NUMBER_OF_BLOCKS

DW 1000

USB_MemMax:
;;DW 0x3fff  ;;to upgrade and add this feature to an existing bootloader project, uncomment "DW 0x3fff" 
                              ;;and reduce the total block count in the protected area below by 2 bytes.  
                              ;;New bootloader projects will be correctly configured at initialization.
;@PSoC_UserCode_BODY1@ (Do not change this line.)
;---------------------------------------------------
; Insert your custom code below this banner
;---------------------------------------------------
;; inserted here to maintain backward compatibility  User must intentionally add this line or
;; delete and restore this file using the code generator.  Do not insert code between this data and the label above
DW 0x3fff


;; insert custom data
;; maintain the size of this area to be EXACTLY ONE block long.  The AppCksum (below)
;; must also be maintained as the last two locations of the block.
;; this maintains compatibility between existing bootloader custom implementations
;; and the expectations of the external tools supplied with this User Module
BLK 48	;old value was 50 -- reduced by two to account for: "DW 0x3fff" (above)

;---------------------------------------------------
; End user Customization
; Insert your custom code above this banner
;---------------------------------------------------
;@PSoC_UserCode_END@ (Do not change this line.)

USB_AppCksum: 		;;last two locations in the block
DW 6383h





;*******************************************************************************
;*** INTERRUPT VECTORS *********************************************************
;*******************************************************************************
; These ISRs are optomized for speed not space.  Further optimization for space
; can be acheived because most of these ISR jump tables end up in the same ISR
; For example bootResetIsr will either ljmp to USB_RESET_ISR or ljmp user_usb_reset_isr
; but that just jumps to USB_RESET_ISR.  This is because this bootloader is sharing
; the USB code space with the trackpad USB transport layer  

area Bootloader(rom,rel)

;*****************************
;*** RESET *******************
;*****************************
bootResetIsr::
   ; Check if all the 4 signature bytes match the signature
   cmp  [BootSignature],SIGNATURE0
   jnz  UserResetIsr
   cmp  [BootSignature+1],SIGNATURE1
   jnz  UserResetIsr
   cmp  [BootSignature+2],SIGNATURE2
   jnz  UserResetIsr
   cmp  [BootSignature+3],SIGNATURE3
   jnz  UserResetIsr

   ; This used to be in the USB_RESET_ISR but this is tighter coding
   mov [LbResetISR], 1
   ; standard reset ISR for USB is used for the bootloader.  User may customize the one in
   ;USBInt.asm 
   push 	A
   push     X
   M8C_SetBank1
   mov		A, reg[USB_USB_CR1]		          ; Get the RegEnable
   M8C_SetBank0
   and 	    A, 0x03					               ; mask off the RegEnable bit
   mov		X, A					                      ; save value in X
   MOV      A, [USB_bCurrentDevice]     ; Select the current device
   LCALL    _USB_Start     ; Restart USB
   POP X
   POP A		
   RETI

UserResetIsr::
   ; If no match, then redirect to user code's USB_RESET vector
   ljmp USB_RESET_USER_ISR_VECTOR


;*****************************
;*** SOF *********************
;*****************************
bootSofIsr::
    ; Check if all the 4 signature bytes match the signature
   cmp  [BootSignature],SIGNATURE0
   jnz  UserSofIsr
   cmp  [BootSignature+1],SIGNATURE1
   jnz  UserSofIsr
   cmp  [BootSignature+2],SIGNATURE2
   jnz  UserSofIsr
   cmp  [BootSignature+3],SIGNATURE3
   jnz  UserSofIsr

   ; Match found.  But there is no handler for SOF in bootloader
   reti

UserSofIsr::
   ; If no match, then redirect to user code's USB_SOF vector
   ljmp USB_SOF_USER_ISR_VECTOR


;*****************************
;*** EP0 *********************
;*****************************
; This is the Interrupt Vector for USB_EP0
bootEp0Isr::
    ; Check if all the 4 signature bytes match the signature
    cmp  [BootSignature],SIGNATURE0
    jnz  UserEp0Isr
    cmp  [BootSignature+1],SIGNATURE1
    jnz  UserEp0Isr
    cmp  [BootSignature+2],SIGNATURE2
    jnz  UserEp0Isr
    cmp  [BootSignature+3],SIGNATURE3
    jnz  UserEp0Isr
    
    ; If match found, redirect to bootloaders EP0 Vector
    ljmp _USB_EP0_ISR

UserEp0Isr::
    ; If no match, then redirect to user code's USB_EP0 vector
    ljmp USB_ENDPT0_USER_ISR_VECTOR


;*****************************
;*** EP1 *********************
;*****************************
bootEp1Isr::
	; Check if all the 4 signature bytes match the signature
    cmp  [BootSignature],SIGNATURE0
    jnz  UserEp1Isr
    cmp  [BootSignature+1],SIGNATURE1
    jnz  UserEp1Isr
    cmp  [BootSignature+2],SIGNATURE2
    jnz  UserEp1Isr
    cmp  [BootSignature+3],SIGNATURE3
    jnz  UserEp1Isr

    ; Match found.  Increment the bEp1Count variable
    mov  [bEp1Count], 1
	;kvn xor [USB_EPDataToggle + 1], USB_CNT_TOGGLE
    XOR  [USB_EPDataToggle], 2 ; Update EP1 data toggle new toggle style

    reti

UserEp1Isr::
    ; If no match, then redirect to user code's USB_EP1 vector
    ljmp USB_ENDPT1_USER_ISR_VECTOR


;*****************************
;*** EP2 *********************
;*****************************
bootEp2Isr::
    ; Check if all the 4 signature bytes match the signature
    cmp  [BootSignature],SIGNATURE0
    jnz  UserEp2Isr
    cmp  [BootSignature+1],SIGNATURE1
    jnz  UserEp2Isr
    cmp  [BootSignature+2],SIGNATURE2
    jnz  UserEp2Isr
    cmp  [BootSignature+3],SIGNATURE3
    jnz  UserEp2Isr

    ; Match found.  Increment the bEp2Count variable
    mov  [bEp2Count], 1
	;kvn xor [USB_EPDataToggle + 2], USB_CNT_TOGGLE
    XOR     [USB_EPDataToggle], 4 ; Update EP2 data toggle new toggle style
	
    reti

UserEp2Isr::
    ; If no match, then redirect to user code's USB_EP2 vector
    ljmp USB_ENDPT2_USER_ISR_VECTOR


;*****************************
;*** EP3 *********************
;*****************************
bootEp3Isr::
	 
    ; Check if all the 4 signature bytes match the signature
    cmp  [BootSignature],SIGNATURE0
    jnz  UserEp3Isr
    cmp  [BootSignature+1],SIGNATURE1
    jnz  UserEp3Isr
    cmp  [BootSignature+2],SIGNATURE2
    jnz  UserEp3Isr
    cmp  [BootSignature+3],SIGNATURE3
    jnz  UserEp3Isr

    ; Match found.  But there is no handler for EP3 in bootloader
    reti

UserEp3Isr::
    ; If no match, then redirect to user code's USB_EP3 vector
    ljmp USB_ENDPT3_USER_ISR_VECTOR

;*****************************
;*** EP4 *********************
;*****************************
bootEp4Isr::
	 
	; Check if all the 4 signature bytes match the signature
    cmp  [BootSignature],SIGNATURE0
    jnz  UserEp4Isr
    cmp  [BootSignature+1],SIGNATURE1
    jnz  UserEp4Isr
    cmp  [BootSignature+2],SIGNATURE2
    jnz  UserEp4Isr
    cmp  [BootSignature+3],SIGNATURE3
    jnz  UserEp4Isr

    ; Match found.  But there is no handler for EP4 in bootloader
    reti

UserEp4Isr::
    ; If no match, then redirect to user code's USB_EP3 vector
    ljmp USB_ENDPT4_USER_ISR_VECTOR


;*****************************
;*** WAKEUP ******************
;*****************************
bootWakeupIsr::
    ; Check if all the 4 signature bytes match the signature
    cmp  [BootSignature],SIGNATURE0
    jnz  UserWakeupIsr
    cmp  [BootSignature+1],SIGNATURE1
    jnz  UserWakeupIsr
    cmp  [BootSignature+2],SIGNATURE2
    jnz  UserWakeupIsr
    cmp  [BootSignature+3],SIGNATURE3
    jnz  UserWakeupIsr

    ; Match found.  But there is no handler for USB_WAKEUP in bootloader
    reti

UserWakeupIsr::
    ; If no match, then redirect to user code's USB_WAKEUP vector
    ljmp USB_WAKEUP_USER_ISR_VECTOR


;*******************************************************************************
;*** PROCEDURES ****************************************************************
;*******************************************************************************


;*******************************************************************************
;*******************************************************************************
;*******************************************************************************
;-----------------------------------------------------------------------------
;  FUNCTION NAME:	EnterBootloader
;
;  DESCRIPTION:		Prepares the processor then enters the bootloader
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS: 		None                  
;
;  RETURNS:			Does not return from this call
;
;  SIDE EFFECTS:	None	
;
;-----------------------------------------------------------------------------
 USB_EnterBootloader:
_USB_EnterBootloader:
 GenericBootloaderEntry:
_GenericBootloaderEntry:

   M8C_DisableGInt

   RAM_SETPAGE_CUR >bootEnteredFromUserCode
   mov [bootEnteredFromUserCode], 0xAA
   
   RAM_SETPAGE_CUR 0
   
   and  F,0x00			 ;;kvn pgmode should not be pg 0 only here.
	
   jmp bootLoaderStart


;*******************************************************************************
;*******************************************************************************
;*******************************************************************************
;-----------------------------------------------------------------------------
;  FUNCTION NAME:: bootLoadVerify
;
;  DESCRIPTION::
;	Calculates checksum for Flash pages USB_AppStartAddr to 
;  USB_AppEndAddr and then compares it with the
;	checksum stored in Flash locations (WORD) USB_AppCksum.  
;   If the checksums are equal
;	the control branches to __StartApp from where the user code can start normally.
;	If the checksum does not equal (previous download fail), the usercode function
;	is called where critical operations can be performed and then jumps to
;	bootloader code where, the processor waits for a 10 byte key from the host
;	to initiate bootload operation
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:: NONE
;
;  SIDE EFFECTS:: NONE
;-----------------------------------------------------------------------------
bootLoaderVerify::	
	
	; If Project development phase, bypass bootloader
	IF (DEBUG)
	   ljmp __StartApp
	ENDIF
   
	; Reset the Error Flags
	or    F, FLAG_PGMODE_11b
	
	RAM_SETPAGE_CUR >bootErrorCode
	mov  [bootErrorCode],0
	mov  [bootErrorCodePrefix],0
	mov  [bootFlag],0
	mov  [bootEnteredFromUserCode], 0

    lcall bootValidateChecksumBlock		;inspect the checksum block to see if it even makes sense

	RAM_SETPAGE_CUR >bootErrorCode
	tst [bootErrorCode],IMAGE_VERIFY_ERROR	
	jnz bootVerifyFail

	lcall verifyChecksumBlock			; Verify checksum in checksum block
	
	RAM_SETPAGE_CUR >bootErrorCode
	tst [bootErrorCode],IMAGE_VERIFY_ERROR	
	jnz bootVerifyFail

	lcall bootVerifyFlashChecksum			; Verify flash checksum
	
	RAM_SETPAGE_CUR >bootErrorCode
	tst [bootErrorCode],IMAGE_VERIFY_ERROR	
	jnz bootVerifyFail
		
        call bootVerifyPassCustomUserCode
		ljmp GenericApplicationStart			; If flash checksum ok, start user code
	bootVerifyFail::
		call bootVerifyFailCustomUserCode		; If flash checksum error execute custom user code
IF	(USB_Bootloader_entry_on_CSUM_fail)
		ljmp bootLoaderStart					; and enter bootloader mode
ELSE
		ljmp GenericApplicationStart			; If flash checksum ok, start user code
ENDIF

	
;*******************************************************************************
;*******************************************************************************
;*******************************************************************************
;-----------------------------------------------------------------------------
;  FUNCTION NAME:: bootVerifyFailCustomUserCode
;
;  DESCRIPTION::
;	Here the user can add his own code to perform system critical tasks in
;	case of failed downloads
;;
;  ARGUMENTS:: NONE
;
;  SIDE EFFECTS:: NONE
;-----------------------------------------------------------------------------
;*****************************************************************************
bootVerifyFailCustomUserCode::
;@PSoC_UserCode_BODY2@ (Do not change this line.)
;---------------------------------------------------
; Insert your custom code below this banner
;---------------------------------------------------

;; insert custom code

;---------------------------------------------------
; End user Customization
; Insert your custom code above this banner
;---------------------------------------------------
;@PSoC_UserCode_END@ (Do not change this line.)
ret

;*******************************************************************************
;*******************************************************************************
;*******************************************************************************
;-----------------------------------------------------------------------------
;  FUNCTION NAME:: bootVerifyPassCustomUserCode
;
;  DESCRIPTION::
;	Here the user can add his own code to perform system critical tasks in
;	case of failed downloads
;;
;  ARGUMENTS:: NONE
;
;  SIDE EFFECTS:: NONE
;-----------------------------------------------------------------------------
;*****************************************************************************
bootVerifyPassCustomUserCode::
;@PSoC_UserCode_BODY3@ (Do not change this line.)
;---------------------------------------------------
; Insert your custom code below this banner
;---------------------------------------------------

;; insert custom code

;---------------------------------------------------
; End user Customization
; Insert your custom code above this banner
;---------------------------------------------------
;@PSoC_UserCode_END@ (Do not change this line.)
ret

;*******************************************************************************
;*******************************************************************************
;*******************************************************************************
;-----------------------------------------------------------------------------
;  FUNCTION NAME:: clearLastBlockCS
;
;  DESCRIPTION::
;	This procedure will clear out the Checksum of the last block of FLASH
;
;  ASSUMPTIONS:: 
; 	Current ram page pointer is same as bootBlockId
;
;  ARGUMENTS:: 
;
;  SIDE EFFECTS:: The main program will not run again until bootloading is complete
;-----------------------------------------------------------------------------
;*****************************************************************************

_clearLastBlockCS::
 clearLastBlockCS::
;@PSoC_UserCode_BODY4@ (Do not change this line.)
;---------------------------------------------------
; Insert your custom code below this banner
;---------------------------------------------------
;; 
;;  if the checksum block is corrupted in just the 'wrong' way it is possible to create a 
;;  correctly checksummed but non functional program.  This code can be use do zero out the 
;;  checksum block on entry into the bootloader.  This may help avoiding this problem.  (as
;;  long as '0000' is considered an incorrect checksum.  Fill in the correct block number for
;;  the checksu to use.
;;
;; insert custom code
;;	mov [bootBlockId], 0        ;bootBlockId MSB place correct block here
;;	mov [bootBlockId + 1], XX  ;bootBlockId LSB	place correct block here
;;	mov [bootFlashBuffer0 + 62], 0x000
;;	mov [bootFlashBuffer0 + 63], 0x000
;;	call bootFlashWR


;---------------------------------------------------
; End user Customization
; Insert your custom code above this banner
;---------------------------------------------------
;@PSoC_UserCode_END@ (Do not change this line.)
ret   

   
;*******************************************************************************
;*******************************************************************************
;*******************************************************************************
;-----------------------------------------------------------------------------
;  FUNCTION NAME:: bootSleep
;
;  DESCRIPTION::
;	This procedure loops until specified number of sleep interupts occure
;
;  ARGUMENTS:: Number of Sleep Timer interrupts to wait for in A
;
;  SIDE EFFECTS:: NONE
;-----------------------------------------------------------------------------
;*****************************************************************************
bootSleep::

	RAM_SETPAGE_CUR >bootTimeoutDelay
	
	mov [<bootTimeoutDelay],A
	
	; Clear any pending sleep interrupt
	and  reg[INT_CLR0], ~INT_MSK0_SLEEP
		
	EnumerationDelay::
		; Check if the Sleep bit is set in INT_CLR0 register
		tst  reg[INT_CLR0], INT_MSK0_SLEEP
	jz EnumerationDelay
		M8C_ClearWDT
		and  reg[INT_CLR0], ~INT_MSK0_SLEEP
		dec  [<bootTimeoutDelay]
	jnz EnumerationDelay
	
ret
   

;*******************************************************************************
;*******************************************************************************
;*******************************************************************************
;-----------------------------------------------------------------------------
; The bootLoader code begins here.  The following operations are performed
;	1. Initialize the processor and start USB and wait till enumeration.
;   2. Wait for a 10 byte bootloader Key from host
; 	3. If Key does not match loop to step 2
;	4. Receive Flash data from host and perform the requested tasks
;	5. Set the flags in bootErrorCode according to the status of operations
;	6. Wait for host to read the Error Code
;	7. Check if there was any error in the previous operation.  If yes reset.
;	8. Check if the BOOTLOAD_DONE flag is set.  If yes start the user code.
;-----------------------------------------------------------------------------
_bootLoaderStart::
bootLoaderStart::

	M8C_ClearWDT
	
	; initialize values for voltage stabilization, if required,
	; leaving power-on reset (POR) level at the default (low) level, at
	; least for now. 
	
	M8C_SetBank1
	mov   reg[VLT_CR], LVD_TBEN_JUST | BTLDR_TRIP_VOLTAGE_JUST
	M8C_SetBank0
	
	and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
	
	 ;---------------------------
	 ;clr pg registers
	 ;---------------------------
     mov reg[CUR_PP], 0
     mov reg[IDX_PP], 0
     mov reg[MVR_PP], 0
     mov reg[MVW_PP], 0
     mov reg[STK_PP], 0

	;---------------------------
	; Set up the Temporary stack
	;---------------------------
	; A temporary stack is set up for the SSC instructions.
	; The real stack start will be assigned later.

	mov   A, 0x80                  ; Set top of stack to end of used RAM
	swap  SP, A                    ; This is only temporary if going to LMM
	
	;---------------------------------------
	; Initialize Crystal Oscillator and PLL
	;---------------------------------------
	
	; Set the CPU speed to 12MHz and the Sleep interval to 8Hz
	M8C_SetBank1
	mov   reg[OSC_CR0], (BL_SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
	M8C_SetBank0
	
	;---------------------------------------------
	; Enter the Large Memory Model
	;---------------------------------------------
	RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
	mov   A, 0x00                  ;   and offset, if any
	swap  A, SP
	RAM_SETPAGE_IDX2STK            ; initialize other page pointers
	RAM_SETPAGE_CUR 0
	RAM_SETPAGE_MVW 0
	RAM_SETPAGE_MVR 0
	;or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
        RAM_RESTORE_NATIVE_PAGING

	M8C_SetBank1
	and  reg[DEC_CR1], 0x3F
	or   reg[DEC_CR1], 0x80
	M8C_SetBank0
	
	; This is a flag to alert the bootloader that a reset has occured
	RAM_SETPAGE_CUR >LbResetISR
	mov [LbResetISR], 0	
	
	
	mov A, 8
	call bootSleep
	lcall USB_Stop
	
	; Disable all interrupts
	mov  reg[INT_MSK0],0
	
	; Clear any pending interrupts which may
	; have been set during the boot process.
	mov  reg[INT_VC],0             
	                               
	
	RAM_SETPAGE_CUR 0
	mov  [BootSignature],SIGNATURE0
	mov  [BootSignature+1],SIGNATURE1
	mov  [BootSignature+2],SIGNATURE2
	mov  [BootSignature+3],SIGNATURE3
	
	
	mov A, 2
	call bootSleep
	
	; Enable Global Interrupts
	M8C_EnableGInt				
	
	; Start USB and enumerate
	call InitializeUsb
	
	; Reset the Error codes
	RAM_SETPAGE_CUR >bootErrorCode
	mov  [bootErrorCode],0
	mov  [bootFlag],0
	
	; START OF LOOP WAITING FOR A VALID KEY
	RAM_SETPAGE_CUR >bootTimeoutDelay
	mov [bootTimeoutDelay], (BOOT_TIMEOUT+BOOT_TIMEOUT+BOOT_TIMEOUT)
	; Clear any pending sleep interrupt
	and  reg[INT_CLR0], ~INT_MSK0_SLEEP
	
	bootWaitForBootLoaderKey::
		RAM_SETPAGE_CUR >bootEnteredFromUserCode
		cmp [bootEnteredFromUserCode], 0
		jz notEnteredFromUserCode
			tst  reg[INT_CLR0], INT_MSK0_SLEEP
			jz   notEnteredFromUserCode
			M8C_ClearWDT
			and  reg[INT_CLR0], ~INT_MSK0_SLEEP
			RAM_SETPAGE_CUR >bootTimeoutDelay
			dec  [bootTimeoutDelay]
	
			; ERROR TIME OUT
IF BOOT_TIMEOUT
			jz   bootLoaderTimeOut
			call   bootLoaderTimeOut
ENDIF
		notEnteredFromUserCode:
	
		mov A,2 
		lcall USB_EnableOutEP
	
		M8C_ClearWDT
		
		RAM_SETPAGE_CUR >LbResetISR
		mov 	A, [LbResetISR]
		jz  	noResetDetected
		mov 	[LbResetISR], 0
		call    InitializeUsb
		
		noResetDetected:: 
		
		//   push a
		//   mov a, 1
		//   call ShowScopeBinary
		//   pop a
		
		RAM_SETPAGE_CUR >bEp2Count
		mov  A,[bEp2Count]
		
		; CONTINUE
		jz bootWaitForBootLoaderKey
	
		; DATA PACKET HAS ARRIVED
		; Read the EP2 buffer to the bootRamBuffer  
		call GetEp2BufferData
		
		; Check if the first byte is 0xFF
		RAM_SETPAGE_CUR >bootRamBuffer
		cmp [bootRamBuffer],0ffh
		; If yes, then proceed to check the command byte
		jz  CheckCommand
		
			; ERROR (BAD FIRST BYTE)
			or [bootErrorCode],INVALID_KEY
         	or  [bootErrorCodePrefix],INVALID_KEY

			jmp  error_bootLoaderStart
		
		CheckCommand::
			; Check if the command is Enter bootload command
			cmp  [bootRamBuffer+1],COMMAND_ENTER_BOOTLOAD
			; If the command is Enter bootload, proceed to check the bootloader
			jz  CheckKey
			
				; ERROR (BAD COMMAND BYTE)
				or   [bootErrorCode],INVALID_COMMAND_ERROR
         	    or  [bootErrorCodePrefix],INVALID_COMMAND_ERROR
				jmp  error_bootLoaderStart
			
			CheckKey::   
				; Verify the 8 byte bootloader key
				call bootVerifyBootLoaderKey
				; Check if the key is valid
				RAM_SETPAGE_CUR >bootErrorCode
				tst [bootErrorCode],INVALID_KEY
				; ERROR (BAD KEY)
				jnz error_bootLoaderStart
				
					; The key is valid.  set the Valid key flag
					or [bootFlag],VALID_KEY
					; Clear the Comm checksum error flag
					and [bootErrorCode],~COMM_CHECKSUM_ERROR
					and [bootErrorCodePrefix],~COMM_CHECKSUM_ERROR
					
					; SUCCESS (ONLY WAY OUT OF THIS PROCEDURE)
					ljmp bootLoaderReceiver
	
	    error_bootLoaderStart:
		; Bootloader has not started, Invalid data packet
		mov  A,USB_TOGGLE
		call WriteErrorCodeToEP1
		
		; Reset error code and loop Back to wait for the correct data packet
		RAM_SETPAGE_CUR >bootErrorCode
		mov  [bootErrorCode],0
        mov  [bootErrorCodePrefix],0
	ljmp bootWaitForBootLoaderKey					


;*******************************************************************************
;*******************************************************************************
;*******************************************************************************
;*****************************************************************************************
;  FUNCTION NAME:: bootLoaderReceiver
;
;  DESCRIPTION:: The following is the sequence of operations performed.
;
;  1. Sets the BOOTLOAD_MODE flag to indicate bootload mode entered.
;  2. Wait for the host to read the status
;  3. Wait for 64 byte packet from host
;  4. Process the received packet
;  5. If any error encountered during processing, reset
;  6. If BOOTLOAD_DONE flag is set, execute user code
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:: NONE
;
;  SIDE EFFECTS:: NONE
;
;*****************************************************************************************
bootLoaderReceiver:

    RAM_SETPAGE_CUR >bootErrorCode
M8C_SetBank1    
    mov A, reg[USB_EP1MODE]
M8C_SetBank0
    mov  A,  reg[USB_INT_REG-3 ] 
    and [bootErrorCode],~IMAGE_VERIFY_ERROR
    and [bootErrorCodePrefix],~IMAGE_VERIFY_ERROR
	or  [bootErrorCode],BOOTLOAD_MODE	; Set flag to indicate BOOTLOAD mode entered
	or  [bootErrorCodePrefix],BOOTLOAD_MODE	; Set flag to indicate BOOTLOAD mode entered
	
	; Set the program CheckSum to 0x0000 so no more frankensteins
	; No more possibility of creating a half bootloaded program with a valid Checksum
	call clearLastBlockCS	 ;;** NO CODE IN THIS ROUTINE **;; user fills out
	;this routine must be filled out by user default is empty code

	; NO ERROR HAS OCCURED, POSTING STATUS THAT BOOTLOAD_MODE HAS BEEN ENTERED
	mov  A,USB_TOGGLE
	call WriteErrorCodeToEP1
	
	; START OF MASTER READ STATUS LOOP
	RAM_SETPAGE_CUR >bootTimeoutDelay
	mov [bootTimeoutDelay], BOOT_TIMEOUT
	; Clear any pending sleep interrupt
	and  reg[INT_CLR0], ~INT_MSK0_SLEEP
	bootWaitForMasterToReadStatus1::
		; Check if the Sleep bit is set in INT_CLR0 register
		tst  reg[INT_CLR0], INT_MSK0_SLEEP
		; If not set, go and check if Host has read from IN endpoint
		jz   CheckEp1Count1
			M8C_ClearWDT
			; A sleep interrupt has occured.  So clear the bit in INT_CLR0 retister
			and  reg[INT_CLR0], ~INT_MSK0_SLEEP
			; Decrement timeout variable
			RAM_SETPAGE_CUR >bootTimeoutDelay
			dec  [bootTimeoutDelay]
			
			; ERROR TIME OUT
IF BOOT_TIMEOUT
			jz   bootLoaderTimeOut
			call   bootLoaderTimeOut
ENDIF
		CheckEp1Count1:
		; Call the function to check if Host has read EP1
		
		//   push a
		//   mov a, 0x40
		//   call ShowScopeBinary
		//   pop a
		
		RAM_SETPAGE_CUR >bEp1Count
		mov  A,[bEp1Count]
		; If not wait for Host to read status or timeout
	jz bootWaitForMasterToReadStatus1	
	
	; Clear the Ep1Count variable
	mov  [bEp1Count],0
	; Set flag to indicate programming mode
	RAM_SETPAGE_CUR >bootFlag
	or   [<bootFlag],PROGRAM				

	; Reset the first 2 bytes of bootRamBuffer
	RAM_SETPAGE_CUR >bootRamBuffer
	mov  [bootRamBuffer],0
	mov  [bootRamBuffer+1],0

	; START OF LOOP RECIEVING 2*BLOCK_COUNT DATA PACKETS										      
	bootReceiveNextFlashPage:
		
		; Reset the EP2 Count variable
		RAM_SETPAGE_CUR >bEp2Count
		mov  [bEp2Count],0	
		
		; Enable OUT Endpoint to receive Flash packet
		mov A,2 
		lcall USB_EnableOutEP
		
		; START OF LOOP MASTER WRITING PACKET
		RAM_SETPAGE_CUR >bootTimeoutDelay
		mov [bootTimeoutDelay],BOOT_TIMEOUT
		; Clear any pending sleep interrupt
		and  reg[INT_CLR0], ~INT_MSK0_SLEEP
		bootWaitForRxComplete::
			; Check if the Sleep bit is set in INT_CLR0 register
			tst  reg[INT_CLR0], INT_MSK0_SLEEP
			; If not set, go and check if Host has written to the OUT Endpoint
			jz   CheckEp2Count
			M8C_ClearWDT
			; A sleep interrupt has occured.  So clear the bit in INT_CLR0 retister
			and  reg[INT_CLR0], ~INT_MSK0_SLEEP
			; Decrement timeout variable
			RAM_SETPAGE_CUR >bootTimeoutDelay
			dec  [bootTimeoutDelay]
			; If timeout variable becomes zero, then a timeout has occured
IF BOOT_TIMEOUT
			jz   bootLoaderTimeOut
			call   bootLoaderTimeOut
ENDIF
			CheckEp2Count::
			; Loop Till Host sends the Flash Data
			//   push a
			//   mov a, 0x41
			//   call ShowScopeBinary
			//   pop a
			
			RAM_SETPAGE_CUR >bEp2Count
			mov  a,[bEp2Count]
		jz bootWaitForRxComplete
		
		; Read the EP2 buffer to the bootRamBuffer  
		call GetEp2BufferData
		
		; Process the Received data packet
		call bootProcessFlashPage
		
		; Update the IN Ep with status code  
		mov  A,USB_TOGGLE
		call WriteErrorCodeToEP1
			
		; START OF LOOP MASTER READ STATUS 
		RAM_SETPAGE_CUR >bootTimeoutDelay
		mov [bootTimeoutDelay],BOOT_TIMEOUT
		; Clear any pending sleep interrupt
		and  reg[INT_CLR0], ~INT_MSK0_SLEEP
		bootWaitForMasterToReadStatus2::
			; Check if the Sleep bit is set in INT_CLR0 register
			tst  reg[INT_CLR0], INT_MSK0_SLEEP
			; If not set, go and check if Host has read from IN endpoint
			jz   CheckEp1Count2
				M8C_ClearWDT
				; A sleep interrupt has occured.  So clear the bit in INT_CLR0 retister
				and  reg[INT_CLR0], ~INT_MSK0_SLEEP
				; Decrement timeout variable
				RAM_SETPAGE_CUR >bootTimeoutDelay
				dec  [bootTimeoutDelay]
		
				; ERROR TIME OUT
IF BOOT_TIMEOUT
				jz   bootLoaderTimeOut
				call   bootLoaderTimeOut
ENDIF	
			CheckEp1Count2:
			; Call the function to check if Host has read EP1
			//   push a
			//   mov a, 0x44
			//   call ShowScopeBinary
			//   pop a
			
			RAM_SETPAGE_CUR >bEp2Count
			mov  A,[bEp1Count]
			; If not wait for Host to read status or timeout
		jz bootWaitForMasterToReadStatus2
		
		; Reset the bEp1Count variable
		mov  [bEp1Count],0
		
		; The host has sent the packet and the packet has been processed.
		; The host has read the status code.
		; Now test the bootErrorcode for any error in the previous operation.
		; If an error exists, perform a Software Reset.
		; Test if the previous Flash Write failed because of
		; flash protection
		RAM_SETPAGE_CUR >bootErrorCode
		tst [<bootErrorCode],FLASH_PROTECTION_ERROR
		jnz ExecuteSwReset
		; Test if the previous Flash Block Verify failed
		tst [<bootErrorCode],IMAGE_VERIFY_ERROR
		jnz ExecuteSwReset
		; Test if invalid key received
		tst [<bootErrorCode],INVALID_KEY
		jnz ExecuteSwReset
		
		
		; No Error in the previous operation.
		; Test if BOOT_COMPLETED_OK flag is set
	tst  [<bootErrorCode],BOOT_COMPLETED_OK	
	; Loop till all the flash pages are done
	jz   bootReceiveNextFlashPage				
	
	; Bootloading completed successfully.
	; Execute a Software reset.  After this reset, the bootLoaderVerify will be called to
	; recheck the user code checksum and then the user code will start executing.
	jmp  ExecuteSwReset


;*******************************************************************************
;*******************************************************************************
;*******************************************************************************
;-----------------------------------------------------------------------------
;  FUNCTION NAME:: ExecuteSwReset
;
;  DESCRIPTION::
;  
;  This function is called either if there is an error in the bootloading or if
;  the bootload completed successfully.  So this function resets all the bootloader flags, 
;  stops the USB and executes a software reset.
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:: NONE
;
;  SIDE EFFECTS:: NONE
;*****************************************************************************************
ExecuteSwReset::
	M8C_DisableGInt
	
	; Stop the USB
	lcall USB_Stop
	
	; Guarantee maximum RAM reset
	mov  reg[CPU_SCR1],0x00
	
	M8C_Reset
	

;*******************************************************************************
;*******************************************************************************
;*******************************************************************************
;-----------------------------------------------------------------------------
;  FUNCTION NAME:: bootLoaderTimeOut
;
;  DESCRIPTION::
;	
;	This function is called when a Read or Write timeout has occured becuase of long
;  period of inactivity from host.  Execute a Reset
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:: NONE
;
;  SIDE EFFECTS:: NONE
;*****************************************************************************************
bootLoaderTimeOut::
   RAM_SETPAGE_CUR >bootErrorCode
   or [bootErrorCode], COMM_CHECKSUM_ERROR ; set Comm error
   jmp  ExecuteSwReset
	

;*******************************************************************************
;*******************************************************************************
;*******************************************************************************
;*****************************************************************************************
;  FUNCTION NAME:: bootProcessFlashPage
;
;  DESCRIPTION:: The following is the sequence of operation
;	1. Verify if the bootLoader key is valid.  If not, skip processing received packet
;	2. If BOOTLOAD_DONE command received jmp to bootLoadDone part
;	3. Check if 1st half of flash data received.  If yes, store it in buffer and return
;  4. Check if 2nd half of flash data received.  If yes, store in buffer and go to
;     step
;  5. Check if FLASH_WRITE command received.  If yes, write the 64 byte Flash data
;		to the block indicated by blockId, and verify the write.
;	6. Check if FLASH_VERIFY command received. If yes, read the 64 bytes Flash data 
;		find checksum and compare with the recordChecksum received from the Master
;	7. If none of the above commands received, set the INVALID_COMMAND flag and exit
;-----------------------------------------------------------------------------
;  ARGUMENTS:: 64 bytes received from the host
;
;  SIDE EFFECTS:: CUR_PP register is modified by this function
;*****************************************************************************************
bootProcessFlashPage::

	M8C_ClearWDTAndSleep;
	; Read the Block Id from the Ram Buffer
	RAM_SETPAGE_CUR >bootBlockId
	mov [bootBlockId],[bootRamBuffer+10]
	mov [bootBlockId+1],[bootRamBuffer+11]
	                                         
	; Read the Command from the Ram Buffer
	mov [bootCommand],[bootRamBuffer+1]
	; Check if Bootloader key is valid
	call bootVerifyBootLoaderKey
	
	RAM_SETPAGE_CUR >bootErrorCode
	tst [bootErrorCode],INVALID_KEY
	; ERROR (INVALID KEY)
	jnz done_bootProcessFlashPage
	
	; Check if BOOTLOAD_DONE command received   
	cmp [bootCommand],COMMAND_BOOTLOAD_DONE		
	; DONE
	jnz bootBypassBootLoadDone
	  
		; Bootload done command received
		; Clear the BOOT_COMPLETED_OK flag	
		and [bootErrorCode],~BOOT_COMPLETED_OK		
		and [bootErrorCodePrefix],~BOOT_COMPLETED_OK		
		; Verify the Flash Checksum
		
		call bootVerifyFlashChecksum				
		
		; Check if Flash checksum was successful
		RAM_SETPAGE_CUR >bootErrorCode
		tst [bootErrorCode],IMAGE_VERIFY_ERROR		
		; ERROR (BAD CS)
		jnz done_bootProcessFlashPage
			; SUCCESS
			or [bootErrorCode],BOOT_COMPLETED_OK
			or [bootErrorCodePrefix],BOOT_COMPLETED_OK
			jmp done_bootProcessFlashPage
	
	bootBypassBootLoadDone::	
		; Verify Checksum of the received packet
		call bootVerifyPacketChecksum
		; Exit if there is packet checksum error
		RAM_SETPAGE_CUR >bootErrorCode
		tst [bootErrorCode],COMM_CHECKSUM_ERROR
		jnz done_bootProcessFlashPage
		
		; Packet checksum is ok
		mov [bootFlashFlag],[bootRamBuffer+12]
		; Test if the Received Flash page is First or second half of flash page
		tst [bootRamBuffer+12],0x01               
		jnz ProcessSecondHalf
		
			; First half of Flash Page received.  
			; Call the StoreFlashData function with an offset of 0
			mov  A,0
			call StoreFlashData
			jmp  ReturnProcessFlashPage
		
		ProcessSecondHalf::
			; Second half of Flash page received
			; Call the StoreFlashData function with an offset of 32
			mov  A,32
			call StoreFlashData
			
			; Check if FLASH_WRITE command received
			RAM_SETPAGE_CUR >bootCommand
			cmp [bootCommand],COMMAND_FLASH_WRITE		
			jnz bootTestFlashVerify
			
				;call bootFlashWrite
	            call bootFlashWR
   
				call bootVerifyFlashBlock

				ReturnProcessFlashPage::
				ret
			
			bootTestFlashVerify::	
				; Check if Flash Verify command has been received
				cmp [bootCommand],COMMAND_FLASH_VERIFY
				; If Flash Verify Command not received, then, set invalid command error
				jnz bootInvalidCommand
					; If Flash Verify command received, read the Flash block and compare it 
					; with the received Flash data
					call bootVerifyFlashBlock
					ret
			
				bootInvalidCommand::
			        RAM_SETPAGE_CUR >bootErrorCode
					or [bootErrorCode],INVALID_COMMAND_ERROR	; If no recognised command received, set the INVALID_COMMAND flag
					or [bootErrorCodePrefix],INVALID_COMMAND_ERROR	; If no recognised command received, set the INVALID_COMMAND flag
done_bootProcessFlashPage:
ret


;*******************************************************************************
;*******************************************************************************
;*******************************************************************************

;  FUNCTION NAME:: StoreFlashData
;
;  DESCRIPTION:: 
;   This function transfers the 32 byte flash data from bootRamBuffer to bootFlashBuffer0
;---------------------------------------------------------------------------------------
;
;  ARGUMENTS:: A contains the offset where the data has to be stored.  For storing the first
;             half of flash data, A contains 0.  For storing 2nd half of flash data
;             A contains 32
;
;  SIDE EFFECTS:: The following Page registers are affected
;                 CUR_PP
;                 MVR_PP
;                 MVW_PP
;
;*****************************************************************************************
StoreFlashData:

	; Set the Source pointer and intialize MVR page pointer
	; to bootRamBuffer+13
	RAM_SETPAGE_CUR >bootSourcePointer
	mov  [bootSourcePointer],<bootRamBuffer+13
	RAM_SETPAGE_MVR >bootRamBuffer
	
	; Set the Destination pointer and initialize MVW page pointer
	; to bootFlashBuffer0
	mov  [bootDestPointer],<bootFlashBuffer0
	; Add the offset to LSB of destination pointer
	add  [bootDestPointer],A
	RAM_SETPAGE_MVW >bootFlashBuffer0
	
	; Init byte count to 32
	mov  [bootByteCount],32
	
	ReadNextByte2::
		; Read from Source
		mvi  A,[bootSourcePointer]
		; Write to Destination
		mvi  [bootDestPointer],A
		; Loop till all bytes transferred
		dec  [bootByteCount]
	jnz  ReadNextByte2
	
ret


;*******************************************************************************
;*******************************************************************************
;*******************************************************************************

;  FUNCTION NAME:: bootVerifyFlashBlock
;
;  DESCRIPTION:: 
;  This function reads 64 bytes from Flash block indicated by blockId and then compares
;  the read data with the data in bootFlashBuffer
;  If the data are same, the FLASH_CHECKSUM_ERROR flag is cleared.  Otherwise it is set.
;---------------------------------------------------------------------------------------
;
;  ARGUMENTS:: NONE
;
;  SIDE EFFECTS:: NONE
;*****************************************************************************************

bootVerifyFlashBlock::
	; Clear the FLASH_CHECKSUM_ERROR bit
	RAM_SETPAGE_CUR >bootErrorCode
	and [bootErrorCode],~FLASH_CHECKSUM_ERROR
	and [bootErrorCodePrefix],~FLASH_CHECKSUM_ERROR
	; Load Accumulator with the Block Number
	mov A,[bootBlockId+1]
	; Call the bootFlashRD function to read the block data to bootFlashBuffer1
	call bootFlashRD
	
	; Now the actual Flash data is available in bootFlashBuffer0 and the data
	; read back from the flash is available in bootFlashBuffer1.
	; Set page mode so that Index instructions are carried out on page pointed
	; by IDX_PP
	RAM_X_POINTS_TO_INDEXPAGE
	; Set the IDX_PP register to point to bootFlashBuffer1
	RAM_SETPAGE_IDX >bootFlashBuffer1
	; Set the MVR_PP register to point to bootFlashBuffer0
	RAM_SETPAGE_MVR >bootFlashBuffer0
	; Set CUR_PP register to point bootByteCount variable
	RAM_SETPAGE_CUR >bootByteCount
	
	mov  [bootByteCount],64
	; Load LSB of bootFlashBuffer1 to X
	mov  X,<bootFlashBuffer1
	; Load LSB of bootFlashBuffer0 to Pointer
	mov  [bootDestPointer], <bootFlashBuffer0
	
	bootAddNextByte::
		; Read from FlashBuffer0
		mvi  A,[bootDestPointer]
		
		; Compare it with FlashBuffer1
		cmp  A,[X]
		; If not equal jump to Flash Verify Error
		;
IF USB_ALLOW_SSC	   ;if using ICE to debug don't fail mismatched flash
        jnz  FlashVerifyError
ENDIF
		;
		; Increment pointer to FlashBuffer1
		inc X
		; Check if 64 bytes have been compared
		dec [bootByteCount]
	jnz bootAddNextByte

	; No error found.  So bypass setting the Flash Checksum error bit
	jmp  FlashVerifyOk

FlashVerifyError::
	RAM_SETPAGE_CUR >bootErrorCode
	or [<bootErrorCode],FLASH_CHECKSUM_ERROR 	; Set FLASH_CHECKSUM_ERROR if checksum does not match
	or [<bootErrorCodePrefix],FLASH_CHECKSUM_ERROR 	; Set FLASH_CHECKSUM_ERROR if checksum does not match
	
	FlashVerifyOk::	
	; Restore native paging
	RAM_RESTORE_NATIVE_PAGING

ret


;*******************************************************************************
;*******************************************************************************
;*******************************************************************************

;  FUNCTION NAME:: bootVerifyBootLoaderKey
;
;  DESCRIPTION::
;	Compares the 8 byte key, KEY1 to KEY8 received from host with the ones declared
;	in the bootloader.inc file.  If the keys match the INVALID_KEY flag is cleared.
;	If the keys do not match, the INVALID_KEY flag is set.
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:: NONE
;
;  SIDE EFFECTS:: This function modifies CUR_PP register
;
;*****************************************************************************************
bootVerifyBootLoaderKey::

	RAM_SETPAGE_CUR >bootErrorCode
	and [bootErrorCode],~INVALID_KEY
	and [bootErrorCodePrefix],~INVALID_KEY
	cmp [bootRamBuffer+2],KEY1
	jnz bootInvalidBootLoaderKey
	cmp [bootRamBuffer+3],KEY2
	jnz bootInvalidBootLoaderKey
	cmp [bootRamBuffer+4],KEY3
	jnz bootInvalidBootLoaderKey
	cmp [bootRamBuffer+5],KEY4
	jnz bootInvalidBootLoaderKey
	cmp [bootRamBuffer+6],KEY5
	jnz bootInvalidBootLoaderKey
	cmp [bootRamBuffer+7],KEY6
	jnz bootInvalidBootLoaderKey
	cmp [bootRamBuffer+8],KEY7
	jnz bootInvalidBootLoaderKey
	cmp [bootRamBuffer+9],KEY8
	jnz bootInvalidBootLoaderKey
	ret

bootInvalidBootLoaderKey::
	or [bootErrorCode],INVALID_KEY
	or [bootErrorCodePrefix],INVALID_KEY

ret
	

;*******************************************************************************
;*******************************************************************************
;*******************************************************************************

;  FUNCTION NAME:: bootVerifyPacketChecksum
;
;  DESCRIPTION:: Verifies the checksum of the received 64 byte data packet.
;
;	Parameters:: 64 bytes received from host stored in bootRamBuffer
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:: NONE
;
;  RETURNS:: Clears the COMM_CHECKSUM_ERROR bit in the bootErrorCode register if checksum 
;           is ok.  Sets the bit if checksum failed
;
;  SIDE EFFECTS:: NONE
;*****************************************************************************************
bootVerifyPacketChecksum::

	; Set Page mode to Index instructions track IDX_PP
	RAM_X_POINTS_TO_INDEXPAGE
	; Set Index page to point at bootRamBuffer page
	RAM_SETPAGE_IDX >bootRamBuffer      
	; Set CUR_PP Register to point to bootRamBuffer.  All the other variables used
	; in this function are located in Page 0.
	RAM_SETPAGE_CUR >bootRamBuffer
	; Initially set the Error code to COMM_CHECKSUM_ERROR
	; This will be cleared if the Packet Checksum is found ok
	or [bootErrorCode],COMM_CHECKSUM_ERROR
	or [bootErrorCodePrefix],COMM_CHECKSUM_ERROR
	
	; Initialize pointer to start of bootRamBuffer
	mov X,<bootRamBuffer
	; Checksum to be calculated for 48 bytes	
	mov [bootByteCount],45
	; Clear the Accumulator. Accumulator will hold the calculated checksum
	mov A,0						
	bootAddNextByteOfPacket::	
		; Add the byte pointed by X to Accumulator 
		add A,[X]
		; Increment the Index
		inc X
		; Check if the checksum has been calculated for all the bytes
		dec [bootByteCount]
	jnz bootAddNextByteOfPacket
	
	; Now X points to the packet checksum in the buffer
	; Compare the received packet checksum with the calculated one
	cmp A,[X]					
	; Branch to Checksum Error if these values do not match
	jnz bootCheckSumError
		bootChecksumOk::
		; We are here if the checksum of the received packet is ok.
		; So clear the CHECKSUM_ERROR Flag
		and [bootErrorCode],~COMM_CHECKSUM_ERROR
		and [bootErrorCodePrefix],~COMM_CHECKSUM_ERROR
	bootCheckSumError::

	; Restore the page mode to native paging
	RAM_RESTORE_NATIVE_PAGING
ret


;*******************************************************************************
;*******************************************************************************
;*******************************************************************************
;  FUNCTION NAME:: bootValidateChecksumBlock
;
;  DESCRIPTION::
;	Run several tests on the contents of the Checksum Block to see if it appears OK.
;	If block contents appear to be ok, IMAGE_VERIFY_ERROR
;	bit is cleared in the bootErrorCode.  Otherwise set
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:: NONE
;
;  RETURNS:: Clears the IMAGE_VERIFY_ERROR bit in the bootErrorCode register if checksum is ok
;			Sets the bit if checksum failed
;  SIDE EFFECTS:: NONE
;
; USB_MAXMEM	  (equ)	 that defines the max memory available in the part
; [USB_MemMax]	  (mem loc in csum block that should contain a (WORD) value identical to the equate above)
;*****************************************************************************************


bootValidateChecksumBlock:
	RAM_SETPAGE_CUR >bootErrorCode
	and [bootErrorCode],~IMAGE_VERIFY_ERROR
	and [bootErrorCodePrefix],~IMAGE_VERIFY_ERROR
;   first just look and see if the equate of the max mem addr agrees with data containg the same value
;   in the checksum block.  This will cover 99% of bad checksum block data
;   get the MSB of MemMax
	mov A,>USB_MemMax
	mov X,<USB_MemMax
	romx	; MSB is in A
    cmp A, 0x30							;this corresponds to empty space in the checksum block and indicates the 
	                                    ;feature is not implemented
    jz  backwardCompat1					;if the MemMax data is 30 in the checksum block assume this feature is not
	                                    ;implemented.  Still test against the equate for MEMMAX for other params
	cmp A, 	>USB_MAXMEM	; cmp with MSB
	jnz bootFlashBlockInvalid
;   get the LSB of MemMax
	mov A,>USB_MemMax
	mov X,<USB_MemMax
    inc X
	adc A, 0
	romx	; LSB is in A
    cmp A, 0x30							;this corresponds to empty space in the checksum block and indicates the 
	                                    ;feature is not implemented
    jz  backwardCompat1					;if the MemMax data is 30 in the checksum block assume this feature is not
	                                    ;implemented.  Still test against the equate for MEMMAX for other params
    cmp A, 	<USB_MAXMEM	 ;cmp with LSB
	jnz bootFlashBlockInvalid
backwardCompat1: 
;call a function to check various addresses in the checksum block to make sure they aren't wildly crazy
	mov A,>USB_AppStart
	mov X,<USB_AppStart
    call  bootValidateMaxRom   ; will check the addr in A, X and verify it is smaller than MAXMEM value

;call a function to check various addresses in the checksum block to make sure they aren't wildly crazy
	mov A,>USB_AppEnd
	mov X,<USB_AppEnd
    call  bootValidateMaxRom   ; will check the addr in A, X and verify it is smaller than MAXMEM value

;calculate the number of blocks available from the MAXMEM value, subtract the NUMBER_OF_BLOCKS val to see 
;if NUMBER_OF_BLOCKS is wildly wrong
;    mov A,>USB_MemMax
;	mov X,<USB_MemMax
;	romx
;	RAM_SETPAGE_CUR >bootBlockCount
;	mov [bootBlockCount],A	   
;	mov A,>USB_MemMax
;    inc X
;	adc a, 0
;	romx
;	mov [bootBlockCount+1],A
;;alternate implementation to above using the equate MAXMEM	avoids using the potentially unimplemented MemMax data location
    mov A,>USB_MAXMEM		; MSB
	RAM_SETPAGE_CUR >bootBlockCount
	mov [bootBlockCount],A	   
	mov A,<USB_MAXMEM
	mov [bootBlockCount+1],A


	asr [bootBlockCount]
	and [bootBlockCount], 0x7f	; zero highest bit incase it was a 1
	rrc [bootBlockCount+1]
	;2 
	asr [bootBlockCount]
	rrc [bootBlockCount+1]
	;4 
	asr [bootBlockCount]
	rrc [bootBlockCount+1]
	;6 
	asr [bootBlockCount]
	rrc [bootBlockCount+1]
	;16 
	asr [bootBlockCount]
	rrc [bootBlockCount+1]
	;32 
	asr [bootBlockCount]
	rrc [bootBlockCount+1]
	;64 max memory is now converted to an Absolute MAX block count 
	; yes, we know that the application can't really take up the entire device but this is a sanity check
    mov A,>USB_AppSize
	mov X,<USB_AppSize
	inc X 
	adc A, 0
	romx	;get the LSB first
    sub  [bootBlockCount+1], A
    mov A,>USB_AppSize
	mov X,<USB_AppSize
	romx	; get the MSB
	sbb  [bootBlockCount], A
	jc 	 bootFlashBlockInvalid ;; if there was a carry (borrow) then the stored AppSize was larger than the entire memory
	                           ;; available on the device

;   getting to this point indicates that none of the above tests failed. 
   	ret
bootFlashBlockInvalid:
;	I2C_Status_Restore
	RAM_SETPAGE_CUR >bootErrorCode
	or [bootErrorCode],IMAGE_VERIFY_ERROR	; On error, set the IMAGE_VERIFY_ERROR bit
	or [bootErrorCodePrefix],IMAGE_VERIFY_ERROR	; On error, set the IMAGE_VERIFY_ERROR bit
	ret

;*******************************************************************************

;  FUNCTION NAME:: bootValidateMaxRom
;
;  DESCRIPTION::
;	use the contents of A, X and verify that the value defined as EQU: USB_MemMax
;   is not exceeded.
;   A contains MSB
;   X contains LSB
;	the checksum stored in 3ffe and 3fffh.  If checksum ok, IMAGE_VERIFY_ERROR
;	bit is cleared in the bootErrorCode.  Otherwise set
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:: NONE
;
;  RETURNS:: Clears the IMAGE_VERIFY_ERROR bit in the bootErrorCode register if checksum is ok
;			Sets the bit if checksum failed
;  SIDE EFFECTS:: NONE
;*****************************************************************************************

bootValidateMaxRom:
    push A	                             ;save the msb
    push X
    inc X								 ;first look at LSB
	romx                                 ;now A has the LSB of the DATA in the address passed in A,X
    sub A, 	<USB_MAXMEM	 ; cmp with LSB
	pop x
	pop A
	romx     							 ; now A has the MSB of the DATA in the address passed in A, X
	sbb A, 	>USB_MAXMEM	 ; sub the MSB, if a carry (borrow) happened MAXMEM was bigger than 
	                                     ; word pointed to by of A, X
    jnc  ValidateAddrError
	ret

ValidateAddrError:
	RAM_SETPAGE_CUR >bootErrorCode
	or [bootErrorCode],IMAGE_VERIFY_ERROR	; On error, set the IMAGE_VERIFY_ERROR bit
	or [bootErrorCodePrefix],IMAGE_VERIFY_ERROR	; On error, set the IMAGE_VERIFY_ERROR bit
    ret


;*******************************************************************************
;*******************************************************************************
;*******************************************************************************

;  FUNCTION NAME:: bootVerifyFlashChecksum
;
;  DESCRIPTION::
;	Calculates the Image checksum from Block 2 to Block 191 and compares with
;	the checksum stored in 3ffe and 3fffh.  If checksum ok, IMAGE_VERIFY_ERROR
;	bit is cleared in the bootErrorCode.  Otherwise set
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:: NONE
;
;  RETURNS:: Clears the IMAGE_VERIFY_ERROR bit in the bootErrorCode register if checksum is ok
;			Sets the bit if checksum failed
;  SIDE EFFECTS:: NONE
;*****************************************************************************************


bootVerifyFlashChecksum:
	RAM_SETPAGE_CUR >bootErrorCode
	and [bootErrorCode],~IMAGE_VERIFY_ERROR
	and [bootErrorCodePrefix],~IMAGE_VERIFY_ERROR
	mov A,>USB_AppStart
	mov X,<USB_AppStart
	romx
	mov [bootRomAddress],A ; hi byte of bootRomAddress
	mov A,>USB_AppStart
    inc X
	romx
	mov [bootRomAddress+1],A  ; lo byte of bootRomAddress	
	mov A,>USB_AppSize
	mov X,<USB_AppSize
	romx
	mov [bootBlockCount],A		; # of blocks msb
	mov A,>USB_AppSize
    inc X
	romx
	mov [bootBlockCount+1],A	; # of blocks lsb
	sub [bootBlockCount+1],1	; adjust count for JNZ later
	sbb [bootBlockCount],0
	inc [bootBlockCount]						
	
	
	mov [bootFlashChecksum],0					; for 16K blks 2 thru 223
	mov [bootFlashChecksum+1],0
	;
	;create a subroutine to accumulate the checksum from more than one range of pages
	;
    call checksumPageRange	  ;collect main app checksum

	mov A,>USB_RelocVectors
	mov X,<USB_RelocVectors
	romx
	RAM_SETPAGE_CUR >bootRomAddress
	mov [bootRomAddress],A ; hi byte of bootRomAddress
	mov A,>USB_RelocVectors
    inc X
	romx
	mov [bootRomAddress+1],A  ; lo byte of bootRomAddress	
	mov [bootBlockCount],1		; # of blocks msb --set to 1 so jnz at end of checksumPageRange works
	mov [bootBlockCount+1],1	; # of blocks lsb -1

    call checksumPageRange	  ;collect reloc Int vectors checksum
    	
	mov X,<USB_AppCksum
;	mov A,3fh
	mov A, >USB_AppCksum				; Load hi byte address of image cs in flash
	romx
	RAM_SETPAGE_CUR >bootFlashChecksum
	cmp A,[bootFlashChecksum]			; Compare High byte of Flash Checksum (stored in 3FFE)
	jnz bootFlashCheckSumFail
	inc X
;	mov A,3fh
	mov A, >USB_AppCksum				; Load hi byte address of image cs in flash
	romx
	cmp A,[bootFlashChecksum+1]			; Compare low byte of Flash Checksum (Stored in 3FFF)
	jnz bootFlashCheckSumFail
;	I2C_Status_Restore
	ret
bootFlashCheckSumFail:
;	I2C_Status_Restore
	or [bootErrorCode],IMAGE_VERIFY_ERROR	; On error, set the IMAGE_VERIFY_ERROR bit
	or [bootErrorCodePrefix],IMAGE_VERIFY_ERROR	; On error, set the IMAGE_VERIFY_ERROR bit
	ret


;*******************************************************************************
;  FUNCTION NAME:: checksumPageRange
;
;  DESCRIPTION::
;
;	Accumulates a checksum for a range of blocks in (WORD) bootFlashChecksum
;   !!! DOES not pre-zero the value of bootFlashChecksum 
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:: 
;   (WORD) bootRomAddress -> Start of blocks to checksum
;	(WORD) bootBlockCount -> number of blocks to checksum - 1 
;  RETURNS:: 
;			
;  SIDE EFFECTS:: NONE
; 
;  NOTE::
;  If your are using ICE, change flashsecurity block to 'U'
;  If your are using silicon, change flashsecurity block to 'R'
;  
;  To verify the checksum block checksum this routine is called at the 
;  entry point-- checksumPartialBlock()
;*******************************************************************************

checksumPageRange:

bootChecksumNextPage:
	mov [bootByteCount],64				; 64 bytes to be added in each block
checksumPartialBlock:					; an alternate entry point to calculate a checksum on a different length of data
bootChecksumNextByte:
IF  WATCHDOG_ENABLE
	M8C_ClearWDT
ENDIF
	mov A,[bootRomAddress]
	mov X,[bootRomAddress+1]
	romx
	add [bootFlashChecksum+1],A
	adc [bootFlashChecksum],0
	add [bootRomAddress+1],1			; increment address
	adc [bootRomAddress],0
	
	dec [bootByteCount]					; decrement byte count
	jnz bootChecksumNextByte			; All 64 bytes done?
	
	sub [bootBlockCount+1],1			; decrement block count
	sbb [bootBlockCount],0
	jnz bootChecksumNextPage			; All  blocks done?
ret

;*******************************************************************************
;*******************************************************************************
;*******************************************************************************

;  FUNCTION NAME:: VerifyChecksumBlock
;
;  DESCRIPTION::
;	Calculates the checksum from the checksum block (last 62 bytes) and compares with
;	the checksum stored in the first two bytes of the checksum block.  If checksum ok, 
;   IMAGE_VERIFY_ERROR bit is cleared in the bootErrorCode.  Otherwise set
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:: NONE
;
;  RETURNS:: Clears the IMAGE_VERIFY_ERROR bit in the bootErrorCode register if checksum is ok
;			Sets the bit if checksum failed
;  SIDE EFFECTS:: NONE
;*****************************************************************************************


verifyChecksumBlock:
	RAM_SETPAGE_CUR >bootErrorCode
	and [bootErrorCode],~IMAGE_VERIFY_ERROR
	and [bootErrorCodePrefix],~IMAGE_VERIFY_ERROR
IF CHECKSUM_ON_CKSUMBLK	  ;;see define in USB_Bt_loader.inc to eliminate
    ;initialize checksum area
	mov [bootFlashChecksum+1], 0
	mov [bootFlashChecksum], 0
	mov A,>USB_CheckSumBlock
	mov [bootRomAddress],A  ; hi byte of bootRomAddress
	mov A,<USB_CheckSumBlock
	mov [bootRomAddress+1],A  ; lo byte of bootRomAddress
	add [bootRomAddress+1], 2 ;move past the checksum stored in the block already
	adc [bootRomAddress], 0 
    ;set up the length (one block)
	mov [bootBlockCount],0		; # of blocks msb --set to 1 so jnz at end of checksumPageRange works
	mov [bootBlockCount+1],1	; # of blocks lsb -1
    	
	;set an initial variable and jump into the routine after this initialization takes place
	mov [bootByteCount],62				; 64 bytes to be added in each block
    call checksumPartialBlock
    	    	
	mov X,<USB_CheckSumBlockCksum
;	mov A,3fh
	mov A, >USB_CheckSumBlockCksum				; Load hi byte address of image cs in flash
	romx
	RAM_SETPAGE_CUR >bootFlashChecksum
	cmp A,[bootFlashChecksum]			; Compare High byte of Flash Checksum (stored in 3FFE)
	jnz checksumBlockCheckSumFail
	inc X
;	mov A,3fh
	mov A, >USB_CheckSumBlockCksum				; Load hi byte address of image cs in flash
	romx
	cmp A,[bootFlashChecksum+1]			; Compare low byte of Flash Checksum (Stored in 3FFF)
	jnz checksumBlockCheckSumFail
;	I2C_Status_Restore
	ret
checksumBlockCheckSumFail:
;	Status_Restore
	or [bootErrorCode],IMAGE_VERIFY_ERROR	; On error, set the IMAGE_VERIFY_ERROR bit
	or [bootErrorCodePrefix],IMAGE_VERIFY_ERROR	; On error, set the IMAGE_VERIFY_ERROR bit
ENDIF ;;( CHECKSUM_ON_CKSUMBLK )

	ret
	
;*******************************************************************************
;*******************************************************************************
;*******************************************************************************

;  FUNCTION NAME:: bootFlashWR
;
;  DESCRIPTION::
;
;	Writes the Flash data to flash block indicated by bootBlockId
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:: 
;   bootBlockId -> Which block to be written first with the content of Buffer0
;
;  RETURNS:: 
;			
;  SIDE EFFECTS:: NONE
; 
;  NOTE::
;  If your are using ICE, change flashsecurity block to 'U'
;  If your are using silicon, change flashsecurity block to 'R'
;*******************************************************************************
IF FLASHLITE

bootFlashWrite:

	; Disable Global Interrupts
	M8C_DisableGInt	
	
		; Clear the FLASH_PROTECTION_ERROR Flag
		RAM_SETPAGE_CUR >bootErrorCode
		
		and  [bootErrorCode],~FLASH_PROTECTION_ERROR	; clear memory error flag
		and  [bootErrorCodePrefix],~FLASH_PROTECTION_ERROR	; clear memory error flag
		
		; Push the Block number to stack
		mov  A,[bootBlockId+1]
		push A                            
		; Push MSB of source pointer to stack
		mov  A,>bootFlashBuffer0
		; Push LSB of source pointer to stack
		push A                            
		mov  A,<bootFlashBuffer0
		push A                            
		; Write Block to Flash
		lcall FlashWriteLite				    
		; Restore Stack    
		add  SP,-3
		                        
		; Check if Flash Write was success. 0 in A means success
		cmp  A, 0
		jz   FlashWriteSuccess
			; If Flash write failed, set the FLASH_PROTECTION_ERROR flag
			RAM_SETPAGE_CUR >bootErrorCode
			or   [bootErrorCode], FLASH_PROTECTION_ERROR
			or   [bootErrorCodePrefix], FLASH_PROTECTION_ERROR
		FlashWriteSuccess::
		
	; Enable Global Interrupts
	M8C_EnableGInt
	
ret

	
;*******************************************************************************
;*******************************************************************************
;*******************************************************************************

;  FUNCTION NAME:: bootFlashRD
;
;  DESCRIPTION::
;
;	Writes the Flash data to flash block indicated by bootBlockId
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:: 
;   bootBlockId -> Which block to be written first with the content of Buffer0
;
;  RETURNS:: 
;			
;  SIDE EFFECTS:: NONE
; 
;  NOTE::
;  If your are using ICE, change flashsecurity block to 'U'
;  If your are using silicon, change flashsecurity block to 'R'
;*******************************************************************************	
bootFlashRD:
	swap A,X                      ; Store Block Id in X
	; Push Byte count
	mov  A, 64 					
	push A                        
	; Push MSB of Block Id
	mov  A,0
	push A
	; Push LSB of Block Id
	push X                        
	; Push MSB of Address
	mov  A,>bootFlashBuffer1
	push A                        
	; Push LSB of address
	mov  A, <bootFlashBuffer1
	push A                         
	lcall FlashReadBlock 			 ; perform the read
	; Restore stack space
	add  sp,-5
ret	
ELSE 

;*******************************************************************************
; Conventional Flashblock.asm api support 
;
; Writing a Block in Flash 	 DO NOT USE with FlashWriteLite routines
; If your are using ICE, change flashsecurity block to 'U'
; If your are using silicon, change flashsecurity block to 'R'
; The structure used here attempts to duplicate the structure of passing parameters used by
; E2PROMlib.asm	(duplicated below)
;------------------------------------------------------
;  Generated Stack Frame for E2ROM Algorithm
;     When E2Write() is called, it will create a 11
;     byte stack frame.  Upon exit, the stack frame
;     will be released.
;------------------------------------------------------
E2_sWriteStruc_wBlockId:         equ      0        ; sWriteStruc - block ID
E2_sWriteStruc_pbFlashBuffer:    equ      2        ; sWriteStruc - flash buffer pointer - 2 bytes
E2_sWriteStruc_cTemperature:     equ      4        ; sWriteStruc - flash Tempurature
E2_sWriteStruc_bPWErase:         equ      5        ; sWriteStruc - temporary storage (reserved)
E2_sWriteStruc_bPWProgram:       equ      6        ; sWriteStruc - temporary storage (reserved)
E2_sWriteStruc_bPWMultiplier:    equ      7        ; sWriteStruc - temporary storage (reserved)
E2_bError:                       equ      8        ; Error result
E2_bBlockOffset:                 equ      9        ; Current block offset
E2_bBlockSizeToWrite:            equ     10        ; Current block size to write
E2_STACK_FRAME_SIZE:             equ     11        ; STACK FRAME Size

FAILURE:                         equ     0xff	   ; error is non zero
;*******************************************************************************

bootFlashWR:
IF (CPU_F)     ;only save CPU flag if NOT CY8C25/26xxx PSoC devices
   mov      A, reg[CPU_F]                            
   push     A
ENDIF
   REG_PRESERVE  IDX_PP
   RAM_SETPAGE_IDX2STK
    ;clear the flash protection error code
    RAM_SETPAGE_CUR >bootErrorCode
	and		[bootErrorCode],~FLASH_PROTECTION_ERROR	; clear memory error flag
	and		[bootErrorCodePrefix],~FLASH_PROTECTION_ERROR	; clear memory error flag
	mov 	X,SP									;
	add 	SP, E2_STACK_FRAME_SIZE 			    ; 11 bytes defined in E2PROMlib.asm
	mov 	a, [bootBlockId]
	mov 	[X + E2_sWriteStruc_wBlockId], A					; Target Block Id LSB
	mov 	a, [bootBlockId+1]
	mov 	[X + E2_sWriteStruc_wBlockId+1], A					; Target Block Id MSB
	
 	mov 	[X + E2_sWriteStruc_pbFlashBuffer],>bootFlashBuffer0
    mov 	[X + E2_sWriteStruc_pbFlashBuffer+1],<bootFlashBuffer0
	mov 	[X + E2_sWriteStruc_cTemperature], TEMPERATURE		; using a constant
	mov 	[X + E2_bBlockSizeToWrite], 0x40		; using a constant always a page at a time
	mov 	[X + E2_bBlockOffset], 0x00		        ; using a constant always a page at a time
;;;;
    mov     [X+E2_bError], FAILURE                    ; Preset fail result
    push    X                                         ; set X = sWriteStruc
    mov     A, X
    add     A, E2_sWriteStruc_wBlockId
    mov     X, A
    mov     A, reg[STK_PP]                            ; set A = MSB(sWriteStruc)=STK_PP

    RAM_PROLOGUE  RAM_USE_CLASS_2                   ; restore the environment
    lcall bFlashWriteBlock                          ; call FlashWriteBlock
    RAM_EPILOGUE RAM_USE_CLASS_2 
;;;;
    pop     X

	cmp		A, 0									; == 0 -> error
	jnz		bootExit_FlashWR						; != 0 -> success
	RAM_SETPAGE_CUR >bootErrorCode
	or		[bootErrorCode], FLASH_PROTECTION_ERROR	; set memory error flag
	or		[bootErrorCodePrefix], FLASH_PROTECTION_ERROR	; set memory error flag
bootExit_FlashWR:
	add 	SP,-E2_STACK_FRAME_SIZE 			    ; recover stack space
    REG_RESTORE  IDX_PP
	reti
	
;*******************************************************************************
; Conventional Flashblock.asm api support 
;
; DO NOT USE with FlashWriteLite routines
;
; Reading a Block in Flash	DO NOT USE with FlashWriteLite routines
;*******************************************************************************
bootFlashRD:
	
    RAM_SETPAGE_IDX2STK
	mov 	x,sp										;
	add 	sp, FLASH_READ_STRUCT_SIZE 					;Sizeof(FLASH_READ_STRUCT)
	mov 	a, [bootRamBuffer+10]
	mov 	[X + wARG_BlockId], A					    ; Target Block Id MSB
	mov 	a, [bootRamBuffer+11]
	mov 	[X + wARG_BlockId+1], A					    ; Target Block Id LSB
	mov 	[X + pARG_FlashBuffer], >bootFlashBuffer1		;MSB of addres
	mov 	[X + pARG_FlashBuffer+1], <bootFlashBuffer1		;LSB of address
	mov 	[X + wARG_ReadCount], 0						;
	mov 	[X + wARG_ReadCount+1], 64 					;read 64 bytes
	mov 	a, reg[STK_PP]											
	lcall 	FlashReadBlock 								;perform the read
	;;RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b				; Keep paging at 00
	add 	sp,-FLASH_READ_STRUCT_SIZE 					;recover stack space
	
	ret	




ENDIF

;*******************************************************************************
;*******************************************************************************
;*******************************************************************************
;------------------------------------------------------------------------------
;	FUNCTION NAME:: GetEp2BufferData
;
;	DESCRIPTION::
;	Transfers the EP2 Buffer to the bootRamBuffer
;
;	ARGUMENTS:: NONE
;                            
;	RETURNS::
;	Data read is returned in the bootRamBuffer.
;
;	SIDE EFFECTS:: A and X registers are modified
;
;------------------------------------------------------------------------------
GetEp2BufferData::
	; Read the Data count received in EP2
	mov  A,2
	lcall USB_wGetEPCount
	; Subtract 2 to get the actual data count as the returned value is
	; inclusive of the CRC
	;; eks GetEPCount subtracts CRC sub  A,2
	; Push MSB of Data Count
	mov  X,0
	push X
	; Push LSB of Data Count
	push A
	; Push MSB of destination buffer address
	mov  A,>bootRamBuffer
	push A
	; Push LSB of destination buffer address
	mov  A,<bootRamBuffer
	push A
	; Push the End Point number
	mov  A,2
	push A
	; Call the bReadOutEP function to transfer the data from the EP buffer
	; to the Ram buffer
	lcall USB_bReadOutEP
	; Restore Stack
	add  SP,-5
	RAM_SETPAGE_CUR >bEp2Count
	mov  [bEp2Count],0
ret   


;*******************************************************************************
;*******************************************************************************
;*******************************************************************************
;------------------------------------------------------------------------------
;	FUNCTION NAME:: WriteErrorCodeToEP1
;
;	DESCRIPTION::
;	Transfers the bootErrorCode to the EP1 buffer
;
;	ARGUMENTS:: Acc to have the USB toggle variable.  The very first time this
;             function is called, it has to be called with USB_NO_TOGGLE.
;             All further calls should be with USB_TOGGLE
;                            
;	RETURNS:: NONE
;
;	SIDE EFFECTS:: A and X registers are modified
;
;------------------------------------------------------------------------------
WriteErrorCodeToEP1::
	RAM_SETPAGE_CUR >bEp1Count
	mov  [bEp1Count],0
	push A	; USB_TOGGLE / USB_NO_TOGGLE
	; Push MSB of Data count
	mov  A,0
	push A
	; Push LSB of Data Count.  This is always 63 but adjustable from file USB_Bt_loader.inc
	mov  A,STATUS_PACKET_SIZE
	push A
	; Push MSB of pointer to bootErrorCode
	mov  A,>bootErrorCodePrefix
	;set the pointer up to make the error code the second byte of the buffer
	push A
	; Push LSB of pointer to bootErrorCode
	mov  A,<bootErrorCodePrefix
	
	push A
	; EP Count = 1
	mov  A,1
	push A
	; Call LoadInEP function to load EP1
	lcall USB_LoadInEP
	; Restore Stack
	add  SP,-6
ret


;*******************************************************************************
;*******************************************************************************
;*******************************************************************************
;------------------------------------------------------------------------------
;	FUNCTION NAME:: InitializeUsb
;
;	DESCRIPTION::
;	Starts USB and waits for the host to enumerate.
;
;	ARGUMENTS:: None
;                            
;	RETURNS:: NONE
;
;	SIDE EFFECTS:: A and X registers are modified
;
;------------------------------------------------------------------------------
InitializeUsb::
	; Start USB at 5V
	;change to 0xff to call the bootloader device
	mov  A,0xff
;@PSoC_UserCode_BODY5@ (Do not change this line.)
;---------------------------------------------------
; Insert your custom code below this banner
;---------------------------------------------------
    ;;change to 3 or 5V parameter depending on operating conditions
	mov  X,USB_BLDR_OPERATION_VLTG ;;USB_5V_OPERATION ;;USB_3V_OPERATION

;---------------------------------------------------
; End user Customization
; Insert your custom code above this banner
;---------------------------------------------------
;@PSoC_UserCode_END@ (Do not change this line.)
	lcall USB_Start
	
	; START OF LOOP Wait for the USB to enumerate.
	WaitForEnumeration::
		M8C_ClearWDT
		lcall USB_bGetConfiguration
	jz   WaitForEnumeration
	
	RAM_SETPAGE_CUR >LbResetISR
	mov [LbResetISR], 0
	
	; Enable EP interrupts
	or reg[USB_INT_REG],(USB_INT_EP1_MASK | USB_INT_EP2_MASK)
	; Enable EP2 to receive the Bootloader packets
	
	; Set up EP1 to NAK
	M8C_SetBank1
	mov reg[USB_EP1MODE], USB_MODE_NAK_IN_OUT
	M8C_SetBank0
	
	RAM_SETPAGE_CUR >bEp2Count
	mov  [bEp2Count],0
	mov  [bEp1Count],0
	
	mov A,2 
	lcall USB_EnableOutEP
ret



