;;*****************************************************************************
;;*****************************************************************************
;;  FILENAME: USB_std.asm
;;  Version: 1.50, Updated on 2011/6/28 at 6:8:6
;;  Generated by PSoC Designer 5.4.2946
;;
;;  DESCRIPTION: USB Device User Module software implementation file.
;;
;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
;;        arguments and observe the associated "Registers are volatile" policy.
;;        This means it is the caller's responsibility to preserve any values
;;        in the X and A registers that are still needed after the API functions
;;        returns. For Large Memory Model devices it is also the caller's 
;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
;;        MVW_PP registers. Even though some of these registers may not be modified
;;        now, there is no guarantee that will remain the case in future releases.
;;-----------------------------------------------------------------------------
;;  Copyright (c) Cypress Semiconductor 2011. All Rights Reserved.
;;*****************************************************************************
;;*****************************************************************************

include "m8c.inc"
include "USB_macros.inc"
include "USB.inc"

;-----------------------------------------------
;  Global Symbols
;-----------------------------------------------
area BootloaderRAM(RAM, REL, CON)

;-----------------------------------------------
;  Constant Definitions
;-----------------------------------------------
;-----------------------------------------------
; Variable Allocation
;-----------------------------------------------

area Bootloader(rom,rel)

;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_Not_Supported
;
;  DESCRIPTION:
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------

; d2h_std_dev
IF (USB_CB_SRC_d2h_std_dev_00 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_dev_00
USB_CB_d2h_std_dev_00:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_01 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_dev_01
USB_CB_d2h_std_dev_01:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_02 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_dev_02
USB_CB_d2h_std_dev_02:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_03 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_dev_03
USB_CB_d2h_std_dev_03:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_04 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_dev_04
USB_CB_d2h_std_dev_04:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_05 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_dev_05
USB_CB_d2h_std_dev_05:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_06 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_dev_06
USB_CB_d2h_std_dev_06:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_07 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_dev_07
USB_CB_d2h_std_dev_07:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_08 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_dev_08
USB_CB_d2h_std_dev_08:
ENDIF

; h2d_std_dev
IF (USB_CB_SRC_h2d_std_dev_00 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_dev_00
USB_CB_h2d_std_dev_00:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_01 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_dev_01
USB_CB_h2d_std_dev_01:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_02 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_dev_02
USB_CB_h2d_std_dev_02:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_03 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_dev_03
USB_CB_h2d_std_dev_03:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_04 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_dev_04
USB_CB_h2d_std_dev_04:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_05 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_dev_05
USB_CB_h2d_std_dev_05:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_06 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_dev_06
USB_CB_h2d_std_dev_06:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_07 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_dev_07
USB_CB_h2d_std_dev_07:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_08 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_dev_08
USB_CB_h2d_std_dev_08:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_09 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_dev_09
USB_CB_h2d_std_dev_09:
ENDIF

; d2h_std_ifc
IF (USB_CB_SRC_d2h_std_ifc_00 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ifc_00
USB_CB_d2h_std_ifc_00:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_01 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ifc_01
USB_CB_d2h_std_ifc_01:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_02 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ifc_02
USB_CB_d2h_std_ifc_02:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_03 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ifc_03
USB_CB_d2h_std_ifc_03:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_04 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ifc_04
USB_CB_d2h_std_ifc_04:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_05 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ifc_05
USB_CB_d2h_std_ifc_05:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_06 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ifc_06
USB_CB_d2h_std_ifc_06:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_07 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ifc_07
USB_CB_d2h_std_ifc_07:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_08 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ifc_08
USB_CB_d2h_std_ifc_08:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_09 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ifc_09
USB_CB_d2h_std_ifc_09:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_10 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ifc_10
USB_CB_d2h_std_ifc_10:
ENDIF

; d2h_std_ifc
IF (USB_CB_SRC_h2d_std_ifc_00 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_ifc_00
USB_CB_h2d_std_ifc_00:
ENDIF
IF (USB_CB_SRC_h2d_std_ifc_01 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_ifc_01
USB_CB_h2d_std_ifc_01:
ENDIF
IF (USB_CB_SRC_h2d_std_ifc_02 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_ifc_02
USB_CB_h2d_std_ifc_02:
ENDIF
IF (USB_CB_SRC_h2d_std_ifc_03 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_ifc_03
USB_CB_h2d_std_ifc_03:
ENDIF
IF (USB_CB_SRC_h2d_std_ifc_04 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_ifc_04
USB_CB_h2d_std_ifc_04:
ENDIF
IF (USB_CB_SRC_h2d_std_ifc_05 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_ifc_05
USB_CB_h2d_std_ifc_05:
ENDIF
IF (USB_CB_SRC_h2d_std_ifc_06 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_ifc_06
USB_CB_h2d_std_ifc_06:
ENDIF
IF (USB_CB_SRC_h2d_std_ifc_07 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_ifc_07
USB_CB_h2d_std_ifc_07:
ENDIF
IF (USB_CB_SRC_h2d_std_ifc_08 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_ifc_08
USB_CB_h2d_std_ifc_08:
ENDIF
IF (USB_CB_SRC_h2d_std_ifc_09 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_ifc_09
USB_CB_h2d_std_ifc_09:
ENDIF
IF (USB_CB_SRC_h2d_std_ifc_10 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_ifc_10
USB_CB_h2d_std_ifc_10:
ENDIF
IF (USB_CB_SRC_h2d_std_ifc_11 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_ifc_11
USB_CB_h2d_std_ifc_11:
ENDIF

; d2h_std_ep
IF (USB_CB_SRC_d2h_std_ep_00 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ep_00
USB_CB_d2h_std_ep_00:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_01 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ep_01
USB_CB_d2h_std_ep_01:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_02 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ep_02
USB_CB_d2h_std_ep_02:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_03 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ep_03
USB_CB_d2h_std_ep_03:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_04 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ep_04
USB_CB_d2h_std_ep_04:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_05 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ep_05
USB_CB_d2h_std_ep_05:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_06 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ep_06
USB_CB_d2h_std_ep_06:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_07 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ep_07
USB_CB_d2h_std_ep_07:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_08 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ep_08
USB_CB_d2h_std_ep_08:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_09 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ep_09
USB_CB_d2h_std_ep_09:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_10 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ep_10
USB_CB_d2h_std_ep_10:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_11 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ep_11
USB_CB_d2h_std_ep_11:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_12 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_std_ep_12
USB_CB_d2h_std_ep_12:
ENDIF

; h2d_std_ep
IF (USB_CB_SRC_h2d_std_ep_00 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_ep_00
USB_CB_h2d_std_ep_00:
ENDIF
IF (USB_CB_SRC_h2d_std_ep_01 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_ep_01
USB_CB_h2d_std_ep_01:
ENDIF
IF (USB_CB_SRC_h2d_std_ep_02 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_ep_02
USB_CB_h2d_std_ep_02:
ENDIF
IF (USB_CB_SRC_h2d_std_ep_03 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_std_ep_03
USB_CB_h2d_std_ep_03:
ENDIF

export  USB_Not_Supported
export _USB_Not_Supported
USB_Not_Supported:
_USB_Not_Supported:
   MOV    A, 0                         ; Count 0
   MOV    X, USB_MODE_STALL_IN_OUT     ; Stall the request
   LJMP   USB_EP0_UPD_MODE_EXIT
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_CB_d2h_std_dev_00
;
;  DESCRIPTION:   Get Device Status
;
;****************************************************************
; STANDARD DEVICE IN REQUEST: Get_Device_Status
;****************************************************************
;
; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h
; bRequest       : GET_STATUS                     = 00h
; wValue         : RESERVED                       = 0000h
; wIndex         : RESERVED                       = 0000h
; wLength        : SIZEOF_ENDPOINT_STATUS         = 0002h
;
; The GET_DEVICE_STATUS request returns the current device status.
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
.LITERAL
GetStatusTransferDescrTable:
    TD_START_TABLE 1                   ; One entry
    TD_ENTRY    USB_DS_RAM, 2, USB_TransferBuffer, NULL_PTR    ; Intermediate Buffer
.ENDLITERAL
IF (USB_CB_SRC_d2h_std_dev_00 & USB_UM_SUPPLIED)
export  USB_CB_d2h_std_dev_00
USB_CB_d2h_std_dev_00:
    mov     [USB_t2], 0                ; Use the UM temp var--Selector

    mov     [USB_TransferBuffer+1], 0    ; Use the UM Transfer Buffer
    mov     [USB_TransferBuffer], [USB_DeviceStatus]

    mov     A, >GetStatusTransferDescrTable    ; Get the ROM Address MSB
    mov     X, <GetStatusTransferDescrTable    ; Get the ROM Address LSB
    jmp     USB_GetTableEntry_Local_Std
ELSE
IF (USB_CB_SRC_d2h_std_dev_00 & USB_APP_SUPPLIED)
export  USB_CB_d2h_std_dev_00
USB_CB_d2h_std_dev_00:
    ljmp    APP_USB_CB_d2h_std_dev_00
ENDIF
ENDIF

;-----------------------------------------------------------------------------
;  USB 2nd Tier Dispactch Jump Tables for Standard Requests (based on bRequest)
;-----------------------------------------------------------------------------
;  FUNCTION NAME: ;  USB 2nd Tier Dispactch Jump Table
;
;  DESCRIPTION:   The following tables dispatch to the Standard request handler
;                 functions.  (Assumes bmRequestType(5:6) is 0, Standard)
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
USB_DT_d2h_std_dev:
;-----------------------------------------------------------------------------

    jmp     USB_CB_d2h_std_dev_00
    jmp     USB_CB_d2h_std_dev_01
    jmp     USB_CB_d2h_std_dev_02
    jmp     USB_CB_d2h_std_dev_03
    jmp     USB_CB_d2h_std_dev_04
    jmp     USB_CB_d2h_std_dev_05
    jmp     USB_CB_d2h_std_dev_06
    jmp     USB_CB_d2h_std_dev_07
    jmp     USB_CB_d2h_std_dev_08

USB_DT_d2h_std_dev_End:
USB_DT_d2h_std_dev_Size: equ (USB_DT_d2h_std_dev_End-USB_DT_d2h_std_dev) / 2
USB_DT_d2h_std_dev_Dispatch::
    mov  A, REG[USB_EP0DATA + bRequest]
    DISPATCHER USB_DT_d2h_std_dev, USB_DT_d2h_std_dev_Size, USB_Not_Supported 

;-----------------------------------------------------------------------------
USB_DT_h2d_std_dev:
;-----------------------------------------------------------------------------

    jmp     USB_CB_h2d_std_dev_00
    jmp     USB_CB_h2d_std_dev_01
    jmp     USB_CB_h2d_std_dev_02
    jmp     USB_CB_h2d_std_dev_03
    jmp     USB_CB_h2d_std_dev_04
    jmp     USB_CB_h2d_std_dev_05
    jmp     USB_CB_h2d_std_dev_06
    jmp     USB_CB_h2d_std_dev_07
    jmp     USB_CB_h2d_std_dev_08
    jmp     USB_CB_h2d_std_dev_09

USB_DT_h2d_std_dev_End:
USB_DT_h2d_std_dev_Size: equ (USB_DT_h2d_std_dev_End-USB_DT_h2d_std_dev) / 2
USB_DT_h2d_std_dev_Dispatch::

    mov   A, REG[USB_EP0DATA + bRequest]
    DISPATCHER USB_DT_h2d_std_dev, USB_DT_h2d_std_dev_Size, USB_Not_Supported 

;-----------------------------------------------------------------------------
USB_DT_d2h_std_ifc:
;-----------------------------------------------------------------------------

    jmp     USB_CB_d2h_std_ifc_00
    jmp     USB_CB_d2h_std_ifc_01
    jmp     USB_CB_d2h_std_ifc_02
    jmp     USB_CB_d2h_std_ifc_03
    jmp     USB_CB_d2h_std_ifc_04
    jmp     USB_CB_d2h_std_ifc_05
    jmp     USB_CB_d2h_std_ifc_06
    jmp     USB_CB_d2h_std_ifc_07
    jmp     USB_CB_d2h_std_ifc_08
    jmp     USB_CB_d2h_std_ifc_09
    jmp     USB_CB_d2h_std_ifc_10

USB_DT_d2h_std_ifc_End:
USB_DT_d2h_std_ifc_Size: equ (USB_DT_d2h_std_ifc_End-USB_DT_d2h_std_ifc) / 2
USB_DT_d2h_std_ifc_Dispatch::
    CMP     [USB_Configuration], 0     ; Is the device configured?
    JNZ     .configured                ; Jump on configured
    JMP    _USB_Not_Supported          ; Stall the request if not configured
; Jump here if the device is configured
.configured:
   mov   A, REG[USB_EP0DATA + bRequest]
    DISPATCHER USB_DT_d2h_std_ifc, USB_DT_d2h_std_ifc_Size, USB_Not_Supported 

;-----------------------------------------------------------------------------
USB_DT_h2d_std_ifc:
;-----------------------------------------------------------------------------

    jmp     USB_CB_h2d_std_ifc_00
    jmp     USB_CB_h2d_std_ifc_01
    jmp     USB_CB_h2d_std_ifc_02
    jmp     USB_CB_h2d_std_ifc_03
    jmp     USB_CB_h2d_std_ifc_04
    jmp     USB_CB_h2d_std_ifc_05
    jmp     USB_CB_h2d_std_ifc_06
    jmp     USB_CB_h2d_std_ifc_07
    jmp     USB_CB_h2d_std_ifc_08
    jmp     USB_CB_h2d_std_ifc_09
    jmp     USB_CB_h2d_std_ifc_10
    jmp     USB_CB_h2d_std_ifc_11

USB_DT_h2d_std_ifc_End:
USB_DT_h2d_std_ifc_Size: equ (USB_DT_h2d_std_ifc_End-USB_DT_h2d_std_ifc) / 2
USB_DT_h2d_std_ifc_Dispatch::
    CMP     [USB_Configuration], 0     ; Is the device configured?
    JNZ     .configured                ; Jump on configured
    JMP    _USB_Not_Supported          ; Stall the request if not configured
; Jump here if the device is configured
.configured:
    mov   A, REG[USB_EP0DATA + bRequest]
    
   ;---------------------------------------------------
   ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
   ;---------------------------------------------------
   ; Add your custom Interface change logic below
   ;---------------------------------------------------    
    
   ;---------------------------------------------------
   ; Insert your custom code above this banner
   ;---------------------------------------------------
   ;@PSoC_UserCode_END@ (Do not change this line.)    

    DISPATCHER USB_DT_h2d_std_ifc, USB_DT_h2d_std_ifc_Size, USB_Not_Supported 

;-----------------------------------------------------------------------------
USB_DT_d2h_std_ep:
;-----------------------------------------------------------------------------

    jmp     USB_CB_d2h_std_ep_00
    jmp     USB_CB_d2h_std_ep_01
    jmp     USB_CB_d2h_std_ep_02
    jmp     USB_CB_d2h_std_ep_03
    jmp     USB_CB_d2h_std_ep_04
    jmp     USB_CB_d2h_std_ep_05
    jmp     USB_CB_d2h_std_ep_06
    jmp     USB_CB_d2h_std_ep_07
    jmp     USB_CB_d2h_std_ep_08
    jmp     USB_CB_d2h_std_ep_09
    jmp     USB_CB_d2h_std_ep_10
    jmp     USB_CB_d2h_std_ep_11
    jmp     USB_CB_d2h_std_ep_12

USB_DT_d2h_std_ep_End:
USB_DT_d2h_std_ep_Size: equ (USB_DT_d2h_std_ep_End-USB_DT_d2h_std_ep) / 2
USB_DT_d2h_std_ep_Dispatch::
    CMP     [USB_Configuration], 0     ; Is the device configured?
    JNZ     .configured                ; Jump on configured

    MOV     A, REG[USB_EP0DATA + wIndexHi] ; Is the request for EP0?
    MOV     [USB_t2], A                ; Use the UM temp var--Selector
    MOV     A, REG[USB_EP0DATA + wIndexLo] ;
    OR      [USB_t2], A                ; Use the UM temp var--Selector
    JZ      .ep0_request

    JMP    _USB_Not_Supported          ; Stall the request if not configured
; Jump here if the device is configured or EP0 request
.configured:
.ep0_request:
    mov   A, REG[USB_EP0DATA + bRequest]
    DISPATCHER USB_DT_d2h_std_ep, USB_DT_d2h_std_ep_Size, USB_Not_Supported 

;-----------------------------------------------------------------------------
USB_DT_h2d_std_ep:
;-----------------------------------------------------------------------------

    jmp     USB_CB_h2d_std_ep_00
    jmp     USB_CB_h2d_std_ep_01
    jmp     USB_CB_h2d_std_ep_02
    jmp     USB_CB_h2d_std_ep_03

USB_DT_h2d_std_ep_End:
USB_DT_h2d_std_ep_Size: equ (USB_DT_h2d_std_ep_End-USB_DT_h2d_std_ep) / 2
USB_DT_h2d_std_ep_Dispatch::
    CMP     [USB_Configuration], 0     ; Is the device configured?
    JNZ     .configured                ; Jump on configured

    MOV     A, REG[USB_EP0DATA + wIndexHi] ; Is the request for EP0?
    MOV     [USB_t2], A                ; Use the UM temp var--Selector
    MOV     A, REG[USB_EP0DATA + wIndexLo] ;
    OR      [USB_t2], A                ; Use the UM temp var--Selector
    JZ      .ep0_request

    JMP    _USB_Not_Supported          ; Stall the request if not configured
; Jump here if the device is configured or EP0 request
.configured:
.ep0_request:
    mov   A, REG[USB_EP0DATA + bRequest]
    DISPATCHER USB_DT_h2d_std_ep, USB_DT_h2d_std_ep_Size, USB_Not_Supported 

USB_GetTableEntry_Local_Std:
    LJMP    USB_GetTableEntry

USB_NoDataStageControlTransfer_Local_Std:
    LJMP    USB_NoDataStageControlTransfer
;-----------------------------------------------
; Add custom application code for routines 
; redefined by USB_APP_SUPPLIED in USB_HID.INC
;-----------------------------------------------

   ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
   ;---------------------------------------------------
   ; Insert your custom code below this banner
   ;---------------------------------------------------

   ;---------------------------------------------------
   ; Insert your custom code above this banner
   ;---------------------------------------------------
   ;@PSoC_UserCode_END@ (Do not change this line.)




;-----------------------------------------------------------------------------
; FUNCTION NAME: USB_CB_d2h_std_dev_06
;
; DESCRIPTION:   Get Device Descriptor
;
;****************************************************************
; STANDARD DEVICE IN REQUEST: Get_Device_Descriptor
;****************************************************************
;
; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h
; bRequest       : GET_DESCRIPTOR                 = 06h    
; wValue         : DESCRIPTOR TYPE | INDEX        = xxxxh  
; wIndex         : ZERO or LANG_ID                = xxxxh
; wLength        : SIZEOF_DESCRIPTOR              = --xxh  
; 
; The GET_DEVICE_DESCRIPTOR returns the specified descriptor if 
; the descriptor exists. 
; 
; The upper byte of wValue contains the descriptor type and 
; the lower byte contains the descriptor index. wIndex 
; contains either 0000h or the Language ID. wLength contains 
; the descriptor length. The actual descriptor information is 
; transferred in subsequent data packets. 
;
;****************************************************************
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_d2h_std_dev_06 & USB_UM_SUPPLIED)
export  USB_CB_d2h_std_dev_06
USB_CB_d2h_std_dev_06:
;-----------------------------------------------------------------------------
; Dispatch to the proper handler
;-----------------------------------------------------------------------------
    mov   A, REG[USB_EP0DATA+wValueHi] ; Get the descrptor type
    asl   A                            ; Make it into a offset
    cmp   A, GET_DESCR_DISPATCH_SIZE         ; Validity check
    jnc   USB_Not_Supported

    JACC    GET_DESCR_DISPATCH

GET_DESCR_DISPATCH:
    jmp   USB_Not_Supported            ; Invalid
    jmp   USB_SendDeviceDescr          ; Device Descriptor
    jmp   USB_SendConfigDescr          ; Configuration Descriptor
IF	USB_bNumStringDescrs                ; Number of String Descriptor defined with the Wizard
    jmp   USB_SendStringDescr          ; String Descriptor
ELSE
    jmp   USB_Not_Supported            ; Not supported if we don't have
                                            ; any String Descriptor
ENDIF

GET_DESCR_DISPATCH_END:
GET_DESCR_DISPATCH_SIZE: EQU (GET_DESCR_DISPATCH_END - GET_DESCR_DISPATCH)     
;-----------------------------------------------------------------------------
; Configuration Descriptor Handler
;-----------------------------------------------------------------------------
USB_SendConfigDescr:
    lcall  USB_GET_DEVICE_TABLE_ENTRY
    swap  A, X
    add   A, 2                         ; We want the pointer to the descriptor table (second entry)
    swap  A, X
    adc   A, 0                         ; Don't forget the carry
    mov  [USB_t2], USB_t1              ; Set up the destination  
    lcall  USB_GETWORD                 ; Get the pointer
    
    mov   A, [USB_t1]                  ; Pointer MSB
    mov   X, [USB_t1+1]                ; Pointer LSB
    
    push  A                            ; Save the MSB
    
    mov   A, REG[USB_EP0DATA+wValueLo] ; Get the descrptor index
    mov   [USB_t2], A                  ; Use the UM temp var--Selector
    pop   A                            ; Need the MSB for the range check
    push  A                            ; Save the MSB for after the range check
    romx                               ; First entry is the table size (only a byte)
    cmp   A, [USB_t2]                  ; Range check
    jnc   .range_ok
    
    pop   A                            ; Fix the stack
    jmp  USB_Not_Supported

.range_ok:
    pop   A                            ; Get the MSB back
    JMP     USB_GetTableEntry_Local_Std
;-----------------------------------------------------------------------------
; Device Descriptor Handler
;-----------------------------------------------------------------------------
USB_SendDeviceDescr:
    CMP     [USB_bCurrentDevice], 0xff
	JZ      .GetBootLoaderDescr
;    mov   [USB_t2], [USB_bCurrentDevice]  ; Use the UM temp var--Selector
    mov   [USB_t2], [USB_bCurrentDevice]  ; Use the UM temp var--Selector
    ;mov   A,>USB_DEVICE_DESCR_TABLE   ; Get the ROM Address MSB
    ;mov   X,<USB_DEVICE_DESCR_TABLE   ; Get the ROM Address LSB
    MOV     A,>Global_Device_Descr_Table_Location  ; Get the ROM Address MSB
    MOV     X,<Global_Device_Descr_Table_Location  ; Get the ROM Address LSB

    romx
	push    A  ; A has hi byte
    MOV     A,>Global_Device_Descr_Table_Location  ; Get the ROM Address LSB
    inc     X
	jnc      .HIDESCRADDROK
    ADC    A, 0
.HIDESCRADDROK:
    romx      ;;A has lo byte which is swapped
    push    A
    Pop     x
    pop     a 


    jmp   .GetDescrEntry
.GetBootLoaderDescr:
    MOV     [USB_t2], 0                ; Use the UM temp var--Selector Bootloader is always 0
    mov   A,>USB_BTLDR_DEVICE_DESCR_TABLE  ; Get the ROM Address MSB
    mov   X,<USB_BTLDR_DEVICE_DESCR_TABLE  ; Get the ROM Address LSB
.GetDescrEntry:
    push  A                            ; Maintain the msb on the stack since it could be from different devices
    romx                               ; First entry is the table size (only a byte)
    cmp   A, [USB_t2]                  ; Range check
    pop   A                            ; recover the original msb from either possible device path (and line up stack before poss. jc)
    jc    USB_Not_Supported

    ;mov   A,>USB_DEVICE_DESCR_TABLE   ; Get the ROM Address MSB

    ljmp   USB_GetTableEntry
;-----------------------------------------------------------------------------
; String Descriptor Handler
;-----------------------------------------------------------------------------
IF	USB_bNumStringDescrs    ; Not needed if we don't have any String Descriptors
USB_SendStringDescr:
    mov   A, REG[USB_EP0DATA+wValueLo] ; Get the descrptor index
    mov   [USB_t2], A                  ; Use the UM temp var--Selector

    CMP     [USB_bCurrentDevice], 0xff
	JZ      .GetBootLoaderStrings

    ;mov   A,>USB_StringTable          ; Get the ROM Address MSB
    ;mov   X,<USB_StringTable          ; Get the ROM Address LSB
    MOV     A,>Global_String_Table_Location  ; Get the ROM Address MSB
    MOV     X,<Global_String_Table_Location  ; Get the ROM Address LSB
    romx
	push    A  ; A has hi byte
    MOV     A,>Global_String_Table_Location  ; Get the ROM Address LSB
    inc     X
	jnc      .HISTRINGADDROK
    ADC    A, 0
.HISTRINGADDROK:
    romx      ;;A has lo byte which is swapped
    push    A
    Pop     x
    pop     a 


	jmp   .GetStringsEntry
.GetBootLoaderStrings:
    mov   A,>USB_BTLDR_StringTable     ; Get the ROM Address MSB
    mov   X,<USB_BTLDR_StringTable     ; Get the ROM Address LSB
.GetStringsEntry:
    push  A                            ; Maintain the msb on the stack since it could be from different devices
    romx                               ; First entry is the table size (only a byte)
    cmp   A, [USB_t2]                  ; Range check
    pop   A                            ; recover the original msb from either possible device path (and line up stack before poss. jc)
    jc    USB_Not_Supported

;    mov   A,>USB_StringTable          ; Get the ROM Address MSB

    JMP     USB_GetTableEntry_Local_Std
ENDIF
ELSE
IF (USB_CB_SRC_d2h_std_dev_06 & USB_APP_SUPPLIED)
export  USB_CB_d2h_std_dev_06
USB_CB_d2h_std_dev_06:
    LJMP    APP_USB_CB_d2h_std_dev_06
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_CB_d2h_std_dev_08
;
;  DESCRIPTION:   Get Device Configuration
;
;****************************************************************
; STANDARD DEVICE IN REQUEST: Get_Device_Configuration
;****************************************************************
;
; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h
; bRequest       : GET_CONFIGURATION              = 08h    
; wValue         : RESERVED                       = 0000h  
; wIndex         : RESERVED                       = 0000h
; wLength        : SIZEOF_DEVICE_CONFIGURATION    = 0001h  
; 
; The GET_DEVICE_CONFIGURATION request returns the currently 
; selected device configuration number. 
;
; request_value and request_index contain 0000h. request_length 
; contains 0001h and the one-byte configuration number is returned 
; in a separate data transfer.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_d2h_std_dev_08 & USB_UM_SUPPLIED)
.LITERAL
GetConfigTransferDescrTable:
    TD_START_TABLE  1                  ; One entry
    TD_ENTRY    USB_DS_RAM, 1, USB_Configuration, NULL_PTR  ; Current configuration
.ENDLITERAL
export  USB_CB_d2h_std_dev_08
USB_CB_d2h_std_dev_08:
    mov   [USB_t2], 0                  ; Use the UM temp var--Selector
    mov   A,>GetConfigTransferDescrTable  ; Get the ROM Address MSB
    mov   X,<GetConfigTransferDescrTable  ; Get the ROM Address LSB
    ljmp   USB_GetTableEntry
ELSE
IF (USB_CB_SRC_d2h_std_dev_08 & USB_APP_SUPPLIED)
export  USB_CB_d2h_std_dev_08
USB_CB_d2h_std_dev_08:
    LJMP    APP_USB_CB_d2h_std_dev_08
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_CB_h2d_std_dev_01
;
;  DESCRIPTION:   Clear Device Feature
;
;****************************************************************
; STANDARD DEVICE OUT REQUEST: Clear_Device_Feature
;****************************************************************
;
; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
; bRequest       : CLEAR_FEATURE                  = 01h    
; wValue         : FEATURE_SELECTOR               = --xxh  
; wIndex         : RESERVED                       = 0000h
; wLength        : RESERVED                       = 0000h  
; 
; The CLEAR_DEVICE_FEATURE request disables a particular feature 
; for a device. The only feature supported for a device is the 
; REMOTE_WAKEUP feature.
; 
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_h2d_std_dev_01 & USB_UM_SUPPLIED)
export  USB_CB_h2d_std_dev_01
USB_CB_h2d_std_dev_01:
    mov   A, REG[USB_EP0DATA+wValueLo] ; Get the Feature Selector
                                       ; Check against valid features
                                       ;  for device receipient
    cmp   A, USB_DEVICE_REMOTE_WAKEUP  ; Only remote wakeup is defined for clear
    jnz   USB_Not_Supported            ;      
    and    [USB_DeviceStatus], ~USB_DEVICE_STATUS_REMOTE_WAKEUP
    ljmp  USB_NoDataStageControlTransfer
ELSE
IF (USB_CB_SRC_h2d_std_dev_01 & USB_APP_SUPPLIED)
export  USB_CB_h2d_std_dev_01
USB_CB_h2d_std_dev_01:
    LJMP    APP_USB_CB_h2d_std_dev_01
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_CB_h2d_std_dev_03
;
;  DESCRIPTION:   Set Device Featue
;
;****************************************************************
; STANDARD DEVICE OUT REQUEST: Set_Device_Feature
;****************************************************************
;
; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
; bRequest       : SET_FEATURE                    = 03h    
; wValue         : FEATURE_SELECTOR               = --xxh  
; wIndex         : RESERVED                       = 0000h
; wLength        : RESERVED                       = 0000h  
; 
; The SET_DEVICE_FEATURE request enables a particular feature
; on a device. The only feature supported for a device is the 
; REMOTE_WAKEUP feature.
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_h2d_std_dev_03 & USB_UM_SUPPLIED)
export  USB_CB_h2d_std_dev_03
USB_CB_h2d_std_dev_03:
    mov   A, REG[USB_EP0DATA+wValueLo] ; Get the Feature Selector
                                       ; Check against valid features
                                       ;  for device receipient
    cmp   A, USB_DEVICE_REMOTE_WAKEUP  ; Remote wakeup?
    jz    .remote_wakeup

    cmp   A, USB_TEST_MODE             ; Test Mode 
    jz    .test_mode
; Flow here for any other selector is invalid for device receipient
    jmp   USB_Not_Supported
; Jump here to enable remote wake up
.remote_wakeup:
    OR      [USB_DeviceStatus], USB_DEVICE_STATUS_REMOTE_WAKEUP
    jmp   .finish
; Jump here to enable test mode
.test_mode:
    jmp   USB_Not_Supported
.finish:
    ljmp  USB_NoDataStageControlTransfer
ELSE
IF (USB_CB_SRC_h2d_std_dev_03 & USB_APP_SUPPLIED)
export  USB_CB_h2d_std_dev_03
USB_CB_h2d_std_dev_03:
    LJMP    APP_USB_CB_h2d_std_dev_03
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_CB_h2d_std_dev_05
;
;  DESCRIPTION:   Set Device Address
;
;****************************************************************
; STANDARD DEVICE OUT REQUEST: Set_Device_Address
;****************************************************************
;
; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
; bRequest       : SET_ADDRESS                    = 05h    
; wValue         : DEVICE_ADDRESS                 = 00xxh  
; wIndex         : RESERVED                       = 0000h
; wLength        : RESERVED                       = 0000h  
; 
; The SET_DEVICE_ADDRESS request sets the USB device address
; for all future USB accesses. 
;
;****************************************************************
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------

IF (USB_CB_SRC_h2d_std_dev_05 & USB_UM_SUPPLIED)
export  USB_CB_h2d_std_dev_05
USB_CB_h2d_std_dev_05:
      
    mov   [USB_fDataPending], USB_ADDRESS_CHANGE_PENDING       
    mov   A, REG[USB_EP0DATA+wValueLo]       
    mov   [USB_TransferBuffer],A       
                                                   
    ljmp  USB_NoDataStageControlTransfer

ELSE
IF (USB_CB_SRC_h2d_std_dev_05 & USB_APP_SUPPLIED)
export  USB_CB_h2d_std_dev_05
USB_CB_h2d_std_dev_05:
    LJMP    APP_USB_CB_h2d_std_dev_05
ENDIF
ENDIF

;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_CB_h2d_std_dev_09
;
;  DESCRIPTION:   Set Configuration
;
;****************************************************************
; STANDARD DEVICE OUT REQUEST: Set_Device_Configuration
;****************************************************************
;
; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
; bRequest       : SET_CONFIGURATION              = 09h    
; wValue         : CONFIGURATION_VALUE            = --xxh  
; wIndex         : RESERVED                       = 0000h
; wLength        : RESERVED                       = 0000h  
; 
; The SET_DEVICE_CONFIGURATION request selects a device 
; configuration to be activated as the current configuration. 
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------

IF (USB_CB_SRC_h2d_std_dev_09 & USB_UM_SUPPLIED)
export  USB_CB_h2d_std_dev_09
USB_CB_h2d_std_dev_09:
    lcall  USB_GET_DEVICE_TABLE_ENTRY  ; Get the selected device
    mov   [USB_t2],USB_t1              ; Set the GETWORD destination 
    lcall  USB_GETWORD                 ; Get the pointer to the CONFIG_LOOKUP table
                                       ; ITempW has the address
    mov   A, REG[USB_EP0DATA+wValueLo] ; Get the configuration number
    mov   [USB_t2],A                   ; Save it 
    mov   A, [USB_t1]                  ; Get the CONFIG_LOOKUP ROM Address MSB
    mov   X, [USB_t1+1]                ; Get the CONFIG_LOOKUP ROM Address LSB
    romx                               ; First entry is the table size (only a byte)
    cmp   A, [USB_t2]                  ; Range check
    jc    USB_Not_Supported

; Refactored from the two loops below
    mov   [USB_Configuration],[USB_t2] ; Save the config number

    cmp   [USB_t2], 0                  ; Unconfigure?
    jz    .unconfigure

; Flow here to configure the endpoints
    mov   A, [USB_t1]                  ; Get the CONFIG_LOOKUP ROM Address MSB
    mov   X, [USB_t1+1]                ; Get the CONFIG_LOOKUP ROM Address LSB
    inc   X                            ; Point to the first table entry
    adc   A, 0                         ;
    mov  [USB_t2], USB_t1              ; Set up the destination  
    lcall  USB_GETWORD                 ; Get the pointer to the CONFIG_LOOKUP table
                                       ; ITempW has the address
    mov   X, 0                         ; Start the index at 0, but we INC first
.configure_next:
    inc   X                            ; Do the next one
    push  X                            ; Save the endpoint number
    mov   A, [USB_t1]                  ; Get the CONFIG_LOOKUP ROM Address MSB
    mov   X, [USB_t1+1]                ; Get the CONFIG_LOOKUP ROM Address LSB
    romx
    inc   [USB_t1+1]                   ; Point to the next 
    adc   [USB_t1], 0                  ;
    pop   X
    call  ConfigureEP                  ; X contains the EP number
                                       ; A contains the EP Direction
    mov   A, X                         ; 
    cmp   A, USB_MAX_EP_NUMBER         ; Configure each of the endpoints
    jnz   .configure_next              ; Do another one?
; Flow here when we are done
    jmp   .done

; Jump here to unconfigure the endpoints
.unconfigure:
    M8C_SetBank1
    mov   X, USB_MAX_EP_NUMBER         ; Configure each of the endpoints
.unconfigure_next:
    mov   [X+USB_EndpointAPIStatus], NO_EVENT_ALLOWED ; For the API
    mov   REG[X+USB_EP1MODE-1], USB_MODE_DISABLE ; Disable the endpoint
    DEC     X                          ; One more down
    jnz   .unconfigure_next            ; Don't unconfigure EP0
	M8C_SetBank0
.done:
    ljmp  USB_NoDataStageControlTransfer
ELSE
IF (USB_CB_SRC_h2d_std_dev_09 & USB_APP_SUPPLIED)
export  USB_CB_h2d_std_dev_09
USB_CB_h2d_std_dev_09:
    LJMP    APP_USB_CB_h2d_std_dev_09
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_CB_d2h_std_ifc_00
;
;  DESCRIPTION:   Get Interface Status
;
;****************************************************************
; STANDARD INTERFACE IN REQUEST: Get_Interface_Status
;****************************************************************
;
; bmRequestType  : (IN | STANDARD | INTERFACE)    = 81h    
; bRequest       : GET_STATUS                     = 00h    
; wValue         : RESERVED                       = 0000h  
; wIndex         : INTERFACE                      = --xxh
; wLength        : SIZEOF_INTERFACE_STATUS        = 0002h  
; 
; The GET_INTERFACE_STATUS request returns status for the 
; specified interface.
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_d2h_std_ifc_00 & USB_UM_SUPPLIED)

.LITERAL
GetInterfaceStatusTransferDescrTable:
    TD_START_TABLE  1                  ; One entry
    TD_ENTRY        USB_DS_RAM, 2, USB_TransferBuffer, NULL_PTR  ; Reuse the transfer buffer
.ENDLITERAL

export  USB_CB_d2h_std_ifc_00
USB_CB_d2h_std_ifc_00:

    mov   [USB_TransferBuffer], 0      ; Zero the transfer buffer
    mov   [USB_TransferBuffer+1], 0    ; 

    mov   [USB_t2], 0                  ; Use the UM temp var--Selector
    mov   A,>GetInterfaceStatusTransferDescrTable  ; Get the ROM Address MSB
    mov   X,<GetInterfaceStatusTransferDescrTable  ; Get the ROM Address LSB

    jmp   USB_GetTableEntry
ELSE
IF (USB_CB_SRC_d2h_std_ifc_00 & USB_APP_SUPPLIED)
export  USB_CB_d2h_std_ifc_00
USB_CB_d2h_std_ifc_00:
    LJMP    APP_USB_CB_d2h_std_ifc_00
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_CB_d2h_std_ifc_10
;
;  DESCRIPTION:   Get Interface
;
;****************************************************************
; STANDARD INTERFACE IN REQUEST: Get_Interface
;****************************************************************
;
; bmRequestType  : (IN | STANDARD | INTERFACE)    = 81h
; bRequest       : GET_INTERFACE                  = 0Ah    
; wValue         : RESERVED                       = 0000h  
; wIndex         : INTERFACE                      = xxxxh
; wLength        : SIZEOF_GET_INTERFACE           = 0001h  
; 
; The GET_INTERFACE request returns the selected alternate 
; setting for the specified interface. 
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------

IF (USB_CB_SRC_d2h_std_ifc_10 & USB_UM_SUPPLIED)

.LITERAL
GetInterfaceTransferDescrTable:
    TD_START_TABLE  1                  ; One entry
    TD_ENTRY        USB_DS_RAM, 1, USB_TransferBuffer, NULL_PTR  ; Reuse the transfer buffer
.ENDLITERAL

export  USB_CB_d2h_std_ifc_10
USB_CB_d2h_std_ifc_10:
    mov   A, REG[USB_EP0DATA+wIndexLo] ; Get the interface number
    CMP     A, 1h                      ; Valid interface number? (UM Parameter: NumInterfaces)
    jnc   USB_Not_Supported

    mov   X, A                         ; The interface number is the index into alternates settings table

    mov   A, [X + USB_InterfaceSetting]  ; Save the current interface setting
    mov   [USB_TransferBuffer], A      ; into the transfer buffer

    mov   [USB_t2], 0                  ; Use the UM temp var--Selector
    mov   A,>GetInterfaceTransferDescrTable  ; Get the ROM Address MSB
    mov   X,<GetInterfaceTransferDescrTable  ; Get the ROM Address LSB

    jmp   USB_GetTableEntry
ELSE
IF (USB_CB_SRC_d2h_std_ifc_10 & USB_APP_SUPPLIED)
export  USB_CB_d2h_std_ifc_10
USB_CB_d2h_std_ifc_10:
    LJMP    APP_USB_CB_d2h_std_ifc_10
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_CB_d2h_std_ep_00
;
;  DESCRIPTION:   Get Endpoint Status
;
;****************************************************************
; STANDARD ENDPOINT IN REQUEST: Get_Endpoint_Status
;****************************************************************
;
; bmRequestType  : (IN | STANDARD | ENDPOINT)     = 82h    
; bRequest       : GET_STATUS                     = 00h    
; wValue         : RESERVED                       = 0000h  
; wIndex         : ENDPOINT                       = 00xxh
; wLength        : SIZEOF_ENDPOINT_STATUS         = 0002h  
; 
; The GET_ENDPOINT_STATUS request returns status for the specified 
; endpoint.
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_d2h_std_ep_00 & USB_UM_SUPPLIED)
export  USB_CB_d2h_std_ep_00
USB_CB_d2h_std_ep_00:
    mov   A, REG[USB_EP0DATA+wIndexLo] ; Get the endpoint number
    and   A, ~USB_DIR_IN               ; Strip off the direction bit
    cmp   A, USB_NUM_ENDPOINTS         ; Range check
    jnc   USB_Not_Supported

    mov   X, A                         ; The endpoint number is the index

    mov   [USB_t2], 0                  ; Use the UM temp var--Selector

    mov   [USB_TransferBuffer + 1], 0  ; Use the UM Transfer Buffer
    mov   A, [X + USB_EndpointStatus]  ; Get the status
    mov   [USB_TransferBuffer], A      ; Save it in the report

    mov   A,>GetStatusTransferDescrTable  ; Get the ROM Address MSB
    mov   X,<GetStatusTransferDescrTable  ; Get the ROM Address LSB

    jmp   USB_GetTableEntry
ELSE
IF (USB_CB_SRC_d2h_std_ep_00 & USB_APP_SUPPLIED)
export  USB_CB_d2h_std_ep_00
USB_CB_d2h_std_ep_00:
    LJMP    APP_USB_CB_d2h_std_ep_00
ENDIF
ENDIF

;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_CB_h2d_std_ep_01
;
;  DESCRIPTION:   Clear Endpoint Feature
;
;****************************************************************
; STANDARD ENDPOINT OUT REQUEST: Clear_Endpoint_Feature
;****************************************************************
;
; bmRequestType  : (OUT | STANDARD | ENDPOINT)    = 02h
; bRequest       : CLEAR_FEATURE                  = 01h    
; wValue         : FEATURE_SELECTOR               = --xxh  
; wIndex         : ENDPOINT                       = 00xxh
; wLength        : RESERVED                       = 0000h  
; 
; The CLEAR_ENDPOINT_FEATURE request disables a particular 
; feature for an endpoint. 
;
; The only feature supported for an endpoint is the EP_HALT 
; feature.
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_h2d_std_ep_01 & USB_UM_SUPPLIED)
export  USB_CB_h2d_std_ep_01
USB_CB_h2d_std_ep_01:
    mov   A, REG[USB_EP0DATA+wValueLo] ; Get the feature selector
    cmp   A, USB_ENDPOINT_HALT         ; Halt is the only selector defined for endpoints
    jnz   USB_Not_Supported

    mov   A, REG[USB_EP0DATA+wIndexLo] ; Get the Endpoint number
    and   A, ~USB_DIR_IN               ; Strip off the direction bit
    cmp   A, 0                         ; Since we can't halt the Control Endpoint
    jz    .done

    cmp   A, USB_NUM_ENDPOINTS         ; Range check
    jnc   USB_Not_Supported

    mov   X, A                         ; Endpoint number is the index
    and   [X+USB_EndpointStatus], ~USB_ENDPOINT_STATUS_HALT  ; Clear the endpoint halt

    push X
	; A already contains the EPnumber so add the LSB to it directy. Carry will be set if overflow, deal with it before romx
    add     A, <USB_USB_EP_BIT_LOOKUP           ; calculate the address LSB
    mov     X, >USB_USB_EP_BIT_LOOKUP           ; calculate the address MSB
    swap    A, X
	adc     A, 0
	romx
	;code above is functionally equivalent to line below but works anywhere in ROM	
    ;INDEX   USB_USB_EP_BIT_LOOKUP ; Get the bit mask
    XOR     A, FFh
    AND     [USB_EPDataToggle], A ; Clear the data toggle for this endpoint
    pop  X

    TST     REG[USB_EP0DATA+wIndexLo], USB_DIR_IN  ; IN or OUT endpoint?
    M8C_SetBank1	                      ; For EP1_MODE register
    jnz   .in

    ; Mark endpoint as empty so it will be reloaded
    MOV     [X+USB_EndpointAPIStatus], NO_EVENT_PENDING
    MOV     REG[X + USB_EP1MODE - 1], USB_MODE_ACK_OUT  ; ACK the endpoint
    JMP     .done
.in:
    MOV     [X+USB_EndpointAPIStatus], EVENT_PENDING
    MOV     REG[X + USB_EP1MODE - 1], USB_MODE_NAK_IN  ; NAK the endpoint
.done:        
	M8C_SetBank0
    JMP     USB_NoDataStageControlTransfer_Local_Std
ELSE
IF (USB_CB_SRC_h2d_std_ep_01 & USB_APP_SUPPLIED)
export  USB_CB_h2d_std_ep_01
USB_CB_h2d_std_ep_01:
    LJMP    APP_USB_CB_h2d_std_ep_01
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_CB_h2d_std_ep_03
;
;  DESCRIPTION:   Set Endpoint Feature
;
;****************************************************************
; STANDARD ENDPOINT OUT REQUEST: Set_Endpoint_Feature
;****************************************************************
;
; bmRequestType  : (OUT | STANDARD | ENDPOINT)    = 02h
; bRequest       : SET_FEATURE                    = 03h    
; wValue         : FEATURE_SELECTOR               = --xxh  
; wIndex         : ENDPOINT                       = 00xxh
; wLength        : RESERVED                       = 0000h  
; 
; The SET_ENDPOINT_FEATURE request enables a particular feature
; for a specific endpoint. The only feature supported for an 
; endpoint is the EP_HALT feature.
; 
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_h2d_std_ep_03 & USB_UM_SUPPLIED)
export  USB_CB_h2d_std_ep_03
USB_CB_h2d_std_ep_03:
    mov   A, REG[USB_EP0DATA+wValueLo] ; Get the feature selector
    cmp   A, USB_ENDPOINT_HALT         ; Halt is the only selector defined for endpoints
    jnz   USB_Not_Supported

    mov   A, REG[USB_EP0DATA+wIndexLo] ; Get the Endpoint number
    and   A, ~USB_DIR_IN               ; Strip off the direction bit
    cmp   A, 0                         ; Never halt the Control Endpoint
    jz    .done

    cmp   A, USB_NUM_ENDPOINTS         ; Range check
    jnc   USB_Not_Supported

    mov   X, A                         ; Endpoint number is the index

    OR      [X+USB_EndpointStatus], USB_ENDPOINT_STATUS_HALT  ; Halt the endpoint
    MOV     [X+USB_EndpointAPIStatus], NO_EVENT_ALLOWED

    TST     REG[USB_EP0DATA+wIndexLo], USB_DIR_IN  ; IN or OUT endpoint?
    M8C_SetBank1	                      ; For EP1_MODE register
    jnz   .in

    MOV     REG[X + USB_EP1MODE - 1], USB_MODE_STALL_DATA_EP | USB_MODE_ACK_OUT  ; Stall the endpoint
    JMP     .done    
.in:
    MOV     REG[X + USB_EP1MODE - 1], USB_MODE_STALL_DATA_EP | USB_MODE_ACK_IN  ; Stall the endpoint
.done:        
	M8C_SetBank0
    JMP     USB_NoDataStageControlTransfer_Local_Std
ELSE
IF (USB_CB_SRC_h2d_std_ep_03 & USB_APP_SUPPLIED)
export  USB_CB_h2d_std_ep_03
USB_CB_h2d_std_ep_03:
    LJMP    APP_USB_CB_h2d_std_ep_03
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: ConfigureEP
;
;  DESCRIPTION:   Configure an endpoint
;
;  ARGUMENTS:    A contains the endpoint direction
;                X contains the endpoint number
;
;  RETURNS:
;
;  SIDE EFFECTS:  The A REGISTER IS VOLATILE.  X REGISTER IS MAINTAINED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
ConfigureEP:
   cmp     A, USB_DIR_UNUSED           ; Is this endpoint unused?
   jnz     .enable                     ; Only enable it if it is used
   ret                                 ; Quick exit if this endpoint is unused

; Jump here to enable an endpoint
.enable:
    push  A                            ; Save the endpoint direction
    mov   A, X                         ; We are using a JACC to dispatch to enable the interrupt
    asl   A                            ;  
    JACC    .EP_INT_ENABLE             ;  

.EP_INT_ENABLE:
    jmp   .EP0IntEnable                ; Enable EP0
    jmp   .EP1IntEnable                ; Enable EP1
    jmp   .EP2IntEnable                ; Enable EP2
    JMP     .EP3IntEnable              ; Enable EP3
    JMP     .EP4IntEnable              ; Enable EP4

; Jump here to enable EP0 Interrupts
.EP0IntEnable:
    M8C_EnableIntMask USB_INT_REG, USB_INT_EP0_MASK
;    JMP   .exit2
    JMP   .cont
.EP1IntEnable:
    M8C_EnableIntMask USB_INT_REG, USB_INT_EP1_MASK
    jmp   .cont
.EP2IntEnable:
    M8C_EnableIntMask USB_INT_REG, USB_INT_EP2_MASK
    jmp   .cont
.EP3IntEnable:
    M8C_EnableIntMask USB_INT_REG, USB_INT_EP3_MASK
    jmp   .cont
.EP4IntEnable:
    M8C_EnableIntMask USB_INT_REG, USB_INT_EP4_MASK
    jmp   .cont
; Jump or flow here to continue configuring the endpoint
;.contEP0:
;    POP   A                           ; Get the endpoint direction back
;    AND   A, USB_DIR_IN               ; Is it an IN endpoint?
;    JNZ   .inEP0                      ; Jump on IN
; Flow here for an OUT Endpoint
; Jump here for an IN Endpoint
;.inEP0:
.cont:
   push     X
    MOV     A, X	                      ; Get the endpoint number from X
    add     A, <USB_USB_EP_BIT_LOOKUP           ; calculate the address LSB
    mov     X, >USB_USB_EP_BIT_LOOKUP           ; calculate the address MSB
    swap    A, X
	adc     A, 0
	romx

	; This index instruction is equivalent to above but assumes that the addr is < 7ff away
	; bad assumption for a bootloader.  The above code works for anywhere in ROM.
    ;INDEX   USB_USB_EP_BIT_LOOKUP	    ; Find bit position for endpoint
    pop     X
    XOR     A, FFh
    AND     [USB_EPDataToggle], A ; Clear the data toggle for this endpoint

    AND     [X+USB_EndpointStatus], ~USB_ENDPOINT_STATUS_HALT  ; Clear any endpoint halts
; if endpoint 0 set EP0MODE
; then exit
;    MOV     A, X	                     ; Get the endpoint number from X
;    CMP     A, EP0	                   ; Is this endpoint zero?
;    JNZ     .enable                   ; Only enable it if it is used

    M8C_SetBank1
    pop   A                            ; Get the endpoint direction back
    and   A, USB_DIR_IN                ; Is it an IN endpoint?
    jnz   .in                          ; Jump on IN
; Flow here for an OUT Endpoint
    MOV   REG[X+USB_EP1MODE-1], USB_MODE_NAK_OUT ; NAK the endpoint
    MOV   [X+USB_EndpointAPIStatus], NO_EVENT_PENDING ; For the API
    jmp   .exit1
; Jump here for an IN Endpoint
.in:
    mov   REG[X+USB_EP1MODE-1], USB_MODE_NAK_IN ; NAK the endpoint
    MOV   [X+USB_EndpointAPIStatus], EVENT_PENDING ; For the API
; Jump or flow here to set the API event and exit    
.exit1:
	M8C_SetBank0
.exit2:
;    MOV   [X+USB_EPDataToggle], 0      ; Clear all EP data toggles?  Is this right?
    RET

; End of File USB_std.asm
