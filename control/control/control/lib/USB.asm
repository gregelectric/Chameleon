;;*****************************************************************************
;;*****************************************************************************
;;  FILENAME: USB.asm
;;   Version: 1.50, Updated on 2011/6/28 at 6:8:6
;;  Generated by PSoC Designer 5.4.2946
;;
;;  DESCRIPTION: USB Device User Module software implementation file
;;
;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
;;        arguments and observe the associated "Registers are volatile" policy.
;;        This means it is the caller's responsibility to preserve any values
;;        in the X and A registers that are still needed after the API functions
;;        returns. For Large Memory Model devices it is also the caller's
;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and
;;        MVW_PP registers. Even though some of these registers may not be modified
;;        now, there is no guarantee that will remain the case in future releases.
;;-----------------------------------------------------------------------------
;;  Copyright (c) Cypress Semiconductor 2011. All Rights Reserved.
;;*****************************************************************************
;;*****************************************************************************

include "m8c.inc"	   
include "memory.inc"
include "USB_macros.inc"
include "USB.inc"

IF 0x3 & 0x10000000
PSOC_ERROR Please run the USB Setup Wizard.  Device Editor, Right Click the USB User Module
; This message will only appear if the USB Setup Wizard has not be run and the descriptors
; and associated data structures have been created.
; After running the USB Setup Wizard, you must also select the Config/Generate Application
; menu item from PSoC Designer in order to generate USB User Module data structures and
; descriptors.
ENDIF
;-----------------------------------------------
;  Global Symbols
;-----------------------------------------------
EXPORT USB_Start
EXPORT _USB_Start
EXPORT USB_Stop
EXPORT _USB_Stop
EXPORT USB_bCheckActivity
EXPORT _USB_bCheckActivity
EXPORT USB_bGetConfiguration
EXPORT _USB_bGetConfiguration
EXPORT USB_bGetEPState
EXPORT _USB_bGetEPState
EXPORT USB_wGetEPCount
EXPORT _USB_wGetEPCount
EXPORT USB_LoadInEP
EXPORT _USB_LoadInEP
EXPORT USB_LoadInISOCEP
EXPORT _USB_LoadInISOCEP
EXPORT USB_EnableOutEP
EXPORT _USB_EnableOutEP
EXPORT USB_EnableOutISOCEP
EXPORT _USB_EnableOutISOCEP
EXPORT USB_DisableOutEP
EXPORT _USB_DisableOutEP
EXPORT USB_bReadOutEP
EXPORT _USB_bReadOutEP
EXPORT USB_Force
EXPORT _USB_Force
EXPORT USB_bGetEPAckState
EXPORT _USB_bGetEPAckState
;EXPORT USB_Suspend
;EXPORT _USB_Suspend
;EXPORT USB_Resume
;EXPORT _USB_Resume
EXPORT USB_bRWUEnabled
EXPORT _USB_bRWUEnabled
EXPORT  USB_SetPowerStatus
EXPORT _USB_SetPowerStatus

AREA BootloaderRAM (RAM, REL, CON)
;-----------------------------------------------
;  Constant Definitions
;-----------------------------------------------

;-----------------------------------------------
;  Variable Allocation
;-----------------------------------------------
EXPORT USB_APITemp
 USB_APITemp:                           BLK   2 ; Two bytes of temporary
                                                ; storage shared by the API
                                                ; functions
EXPORT USB_APIEPNumber, _USB_APIEPNumber
_USB_APIEPNumber:
 USB_APIEPNumber:                      BLK   1 ; API storage for speed
EXPORT USB_APICount, _USB_APICount
_USB_APICount:
 USB_APICount:                         BLK   1 ; API storage for speed

EXPORT USB_bActivity, _USB_bActivity
_USB_bActivity:
 USB_bActivity:                        BLK   1 ; Activity flag (Shared between the ISR and API)
;-----------------------------------------------
;  Constant Data Allocation
;-----------------------------------------------
area Bootloader(rom,rel)
EXPORT USB_USB_EP_BIT_LOOKUP
.LITERAL
USB_USB_EP_BIT_LOOKUP:  ;
    DB     01H                       ; EP0
    DB     02H                       ; EP1
    DB     04H                       ; EP2
    DB     08H                       ; EP3
    DB     010H                      ; EP4
.ENDLITERAL

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_Start
;
;  DESCRIPTION:    Starts the USB User Module
;                    Sets the device selection
;                    Set the configuration to unconfigured
;                    Enables the SIE for Address 0
;                    Enables the USB pullup (D- for low speed, D+ for full speed)
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    A is the desired device
;                X is the operation voltage
;
;  RETURNS:		 Nothing
;
;  SIDE EFFECTS: 
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USB_Start:
_USB_Start:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_PROLOGUE RAM_USE_CLASS_3
        RAM_SETPAGE_CUR >USB_bCurrentDevice ; Set the CUR_PP to the right page
    RAM_SETPAGE_IDX >USB_bCurrentDevice; Set the IDX_PP to the right page
    push    X
    mov     [USB_bCurrentDevice], A    ; The app selects the desired device

    mov     [USB_TransferType], USB_TRANS_STATE_IDLE ; Transaction Idle State
    mov     [USB_Configuration], 0     ; Unconfigured
    mov     [USB_DeviceStatus], 0      ; Clears device status

    MOV     [USB_EPDataToggle], 0      ; Clear all EP data toggles

    mov     reg[TMP_DR0], 0	           ; EP1 start address in PMA space
	mov     reg[TMP_DR1], 64              ; EP2 start address in PMA space
	mov     reg[TMP_DR2], 128             ; EP3 start address in PMA space
	mov     reg[TMP_DR3], 192             ; EP4 start address in PMA space

;    mov     X, USB_MAX_EP_NUMBER      ; Set up loop to clear all of the endpoint data items
; Flow or jump here to clear the data for the next endpoint
;.loop:
;    mov     [X + USB_EPDataToggle], 0 ; Or in the toggle
;    dec     X                         ; Are we done?
;    jnz     .loop                     ; Jump to do another endpoint

 IF (USB_CLASS & USB_CLASS_HID)
    ; Initialize USB_Protocol variable to comply with HID 7.2.6 Set_Protocol Request: 
    ; "When initialized, all devices default to report protocol." 
    
    cmp A, BOOTLOADER_MODE      ; skop the HID_Protocol initialization, when we are in the bootLoader Mode
    jz  .bootMode    
    
    mov     X, 1-1                     ;number of interfaces -1 
.loop:
    mov     [X + USB_Protocol], 1      ; Protocol = Report
    dec     X                                ;Are we done?
    jnc     .loop                            ;Jump to do another interface
.bootMode:    
ENDIF

; Flow here to enable the SIE

    mov     reg[USB_ADDR], USB_ADDR_ENABLE ; Enable Address 0
	mov     reg[USB_USBIO_CR0], USB_AUTO_DPDM

; Set the Operating Voltage at which the chip will run
    pop     A
    M8C_SetBank1
	mov     reg[USB_USB_CR1], A
	M8C_SetBank0
    mov     reg[USB_EP0MODE], USB_MODE_STALL_IN_OUT ; ACK Setup/Stall IN/OUT
    M8C_EnableIntMask USB_INT_REG, (USB_INT_RESET_MASK | USB_INT_EP0_MASK)

;   Enable the pullup so we can start to rock and roll
    mov     reg[USB_USBIO_CR1], USB_PULLUP_ENABLE ; Pullup D+

    RAM_EPILOGUE RAM_USE_CLASS_3
	RAM_EPILOGUE RAM_USE_CLASS_4
    RET
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_Stop
;
;  DESCRIPTION:
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS: None
;
;  RETURNS:   Nothing
;
;  SIDE EFFECTS: 
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USB_Stop:
_USB_Stop:
    RAM_PROLOGUE RAM_USE_CLASS_4
	RAM_SETPAGE_CUR >USB_bCurrentDevice   ; Set the CUR_PP to the right page

    mov     [USB_bCurrentDevice], 0    ; The app selects the desired device

    mov     [USB_TransferType], USB_TRANS_STATE_IDLE ; Transaction Idle State
    mov     [USB_Configuration], 0     ; Unconfigured
    mov     [USB_DeviceStatus], 0      ; Clears device status
    mov     reg[USB_ADDR], 0           ; Clear the addfress and Address 0

    and     reg[USB_USBIO_CR1], ~USB_PULLUP_ENABLE ; Release D-
    mov     reg[USB_INT_REG], 0x00 ; DISable the interrupt

	RAM_EPILOGUE RAM_USE_CLASS_4
    RET
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_bCheckActivity
;
;  DESCRIPTION:
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS: Nothing
;
;  RETURNS:   A is a flag that indicates bus activity 
;
;  SIDE EFFECTS: ;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USB_bCheckActivity:
_USB_bCheckActivity:
    RAM_PROLOGUE RAM_USE_CLASS_1
    M8C_SetBank1
    mov    A, reg[USB_USB_CR1]         ; USB Activity bit indicates activity
    and    A, USB_BUS_ACTIVITY         ; Activity?
    jz     .no_activity                ; Jump on no activity?
; Flow here on bus activity
    mov    A, 1                        ; Return true
    jmp    .done
; Jump here on no activity
.no_activity:
    mov    A, 0                        ; Return false
; Jump or flow here to clear the activity bit, then return
.done:
    and    reg[USB_USB_CR1], ~USB_BUS_ACTIVITY  ; Clear the activity flag
    M8C_SetBank0
	RAM_EPILOGUE RAM_USE_CLASS_1
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_bGetConfiguration
;
;  DESCRIPTION:   Returns the current configuration number
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    None
;
;  RETURNS:      A contains the current configuration number
;
;  SIDE EFFECTS: 
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USB_bGetConfiguration:
_USB_bGetConfiguration:
	RAM_PROLOGUE RAM_USE_CLASS_4
	RAM_SETPAGE_CUR >USB_Configuration
    mov     A,[USB_Configuration]
	RAM_EPILOGUE RAM_USE_CLASS_4
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_bGetEPState
;
;  DESCRIPTION:
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    A contains the endpoint number 
;
;  RETURNS:      A contains the endpoint state
;
;  SIDE EFFECTS: 
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16 
;    functions.
;
 USB_bGetEPState:
_USB_bGetEPState:
    RAM_PROLOGUE RAM_USE_CLASS_3
	RAM_SETPAGE_IDX >USB_EndpointAPIStatus
    cmp     A, (USB_MAX_EP_NUMBER + 1) ; Range check
    jnc     .invalid_ep                ; Bail out
; Flow here to enable an endpoint        
    mov     X, A                       ; Endpoint number is the index
    mov     A, [X+USB_EndpointAPIStatus]; Get the state
    jmp     .exit                      ; Go to the common exit
; Jump here for an invalid endpoint
.invalid_ep:
    mov     A, 0                       ; Return 0 for an invalid ep
; Jump or flow here for a common exit
.exit:
    RAM_EPILOGUE RAM_USE_CLASS_3
    ret                                ; All done
.ENDSECTION



;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_bRWUEnabled
;
;  DESCRIPTION:   Returns 1 if Remote Wake Up is enabled, otherwise 0
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:   None
;
;  RETURNS:     A: 1--Remote Wake Up Enabled
;                  0--Remote Wake Up Disabled
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
.SECTION
 USB_bRWUEnabled:
_USB_bRWUEnabled:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_SETPAGE_CUR >USB_DeviceStatus
    TST     [USB_DeviceStatus], USB_DEVICE_STATUS_REMOTE_WAKEUP
    JNZ     .enabled                   ; Jump if enabled
; Flow here if RWU is disabled
    MOV     A, 0                       ; Return disabled
    JMP     .exit                      ; Go to the common exit
; Jump when RWU is enabled
.enabled:
    MOV     A, 1                       ; Return enabled
; Jump or flow here for a common exit
.exit:
    RAM_EPILOGUE RAM_USE_CLASS_4
    RET                                ; All done
.ENDSECTION

;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_bGetEPCount
;
;  DESCRIPTION:
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    A contains the Endpoint Number
;
;  RETURNS:		 A and X contain a WORD that indicate the values stored in the
;                Count registers of the Endpoint
;
;  SIDE EFFECTS: 
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16 
;    functions.
;
.SECTION
 USB_wGetEPCount:
_USB_wGetEPCount:
    RAM_PROLOGUE RAM_USE_CLASS_1
    cmp     A, (USB_MAX_EP_NUMBER + 1) ; Range check
    jnc     .invalid_ep                ; Bail out
; Flow here to get the endpoint count
    asl     A                          ; Multiply the index by two to get to the value   
    mov     X, A                       ; Endpoint number is the index
    mov     A, reg[X+USB_EP1CNT1 - 1]  ; Here is the count
        sub     A, 2
    push    A
	dec     X
	mov     A, reg[X+USB_EP1CNT1 - 1]     ; Here is the count
        and     A, 0x01
    mov     X, A
	pop     A
    jmp     .exit                      ; Go to the common exit
; Jump here for an invalid endpoint
.invalid_ep:
    mov     A, 0                       ; Return 0 for an invalid ep
; Jump or flow here for a common exit
.exit:
    RAM_EPILOGUE RAM_USE_CLASS_1
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_LoadInEP and USB_LoadInISOCEP
;
;  DESCRIPTION:    This function loads the specified USB endpoint with
;                  the data specified.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;     [SP-8] Toggle
;     [SP-7] MSB of Count to send
;     [SP-6] LSB of Count to send
;     [SP-5] MSB of data array address
;     [SP-4] LSB of data array address
;     [SP-3] Endpoint Number
;
;  RETURNS:
;     none
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
;    Currently only the page pointer registers listed below are modified:
;          CUR_PP
;          IDX_PP
;
EP_TYPE:        equ -1
; -2 and -3 is the return address to caller
EP_NUM:     equ -4                       ; Endpoint Number
DATA_LSB:   equ -5           ; LSB pointer of data
DATA_MSB:   equ -6           ; MSB pointer of data
CNTLEN_LSB: equ -7
CNTLEN_MSB: equ -8           ; Length of data to send
TOGGLE:     equ -9

 USB_LoadInISOCEP:
_USB_LoadInISOCEP:
        mov             A, USB_MODE_ISO_IN
        push    A
        jmp             BodyLoadIN_USB
 USB_LoadInEP:
_USB_LoadInEP:
        mov             A, USB_MODE_ACK_IN
        push    A
BodyLoadIN_USB:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_PROLOGUE RAM_USE_CLASS_3
	RAM_SETPAGE_CUR >USB_bCurrentDevice   ; Set the CUR_PP to the right page
    RAM_SETPAGE_IDX2STK    
	mov     X, SP
	mov     A, [X+EP_NUM]
	cmp     A, USB_MAX_EP_NUMBER+1        ; Range check
    jnc     .exit                      ; Bail out

    ;SET THE COUNT
	mov     A, [X+CNTLEN_MSB]             ; Get the MSB of the Count	
	and     A, 0x01                       ; Mask off the count bit
	mov     [USB_APITemp+1], A            ; Save the count
	mov     A, [X+CNTLEN_LSB]             ; Get the LSB of the Count
	mov     [USB_APITemp], A              ; Save the count


        ;  Perform normal data toggle or bypass?
        push    X
        mov     A, [X+TOGGLE]
        jnz      .normalToggle

		; the endpoint ISR automatically toggles the endpoint, so to support
		; the idea of not having the toggle change we must untoggle here.
        mov     A, <USB_USB_EP_BIT_LOOKUP           ; calculate the address LSB
        add     A, [X+EP_NUM]           ; Get the Endpoint number
        mov     X, >USB_USB_EP_BIT_LOOKUP           ; calculate the address MSB
        swap    A, X
		adc     A, 0
		romx
	    pop     X	                        ; Restore X to obtain the endpt correctly in the next block
       	push    X
		
        ;INDEX   USB_USB_EP_BIT_LOOKUP ; Get the bit mask
        XOR     [USB_EPDataToggle], A ; Retoggle the toggle

.normalToggle:              
        mov     A, <USB_USB_EP_BIT_LOOKUP           ; calculate the address LSB
        add     A, [X+EP_NUM]           ; Get the Endpoint number
        mov     X, >USB_USB_EP_BIT_LOOKUP           ; calculate the address MSB
        swap    A, X
		adc     A, 0
		romx	;now A contains the toggle
		
        ;INDEX   USB_USB_EP_BIT_LOOKUP ; Get the bit mask
		pop     x	 ;do before the and so the zero flag won't be corrupted.
        AND     A, [USB_EPDataToggle]
        JZ      .toggle0

        and      [USB_APITemp+1], ~USB_CNT_TOGGLE ; Set the data toggle
        JMP     .toggle_done
.toggle0:
        or     [USB_APITemp+1], USB_CNT_TOGGLE
                
.toggle_done:

    RAM_SETPAGE_IDX2STK
    mov     X, SP
	mov     A, [X+EP_NUM]                  ; Get the Endpoint number 					
	asl     A                              ; Double the ep number for proper cnt access
	mov     X, A                           ; Make it into an index
	mov     A, [USB_APITemp]               ; Retrieve the saved MSB 
    mov     reg[X+USB_EP1CNT1 - 1], A   ; Write it into the register
    dec     X                           ; Decrement the index to access the LSB
	mov     A, [USB_APITemp+1]             ; Retrieve the saved LSB
	mov     reg[X+USB_EP1CNT1 - 1], A      ; Write it into the register
    
; It's Time to move the data

; First we need to determine where within the PMA the EP Start Address is
	mov     X, SP                          ; Get the Stack Pointer
	mov     A, [X+EP_NUM]                  ; Get the Endpoint number
	mov     X, A                           ; Use the EP number as an index
	mov     A, reg[X+TMP_DR0-1]            ; Get the address of ep from tmp register 
	M8C_SetBank1
        M8C_DisableGInt
	mov     reg[PMA0_WA], A                ; Set the Write pointer of our pma to ep space 
        M8C_EnableGInt
	M8C_SetBank0	

; Now we are ready to start moving data
    mov     X, SP
	and     [X+CNTLEN_MSB], 0x01           ; Mask off the MSB bit
	jnz     .start_send	                   ; If it is high then we have 256 bytes
	mov     A, [X+CNTLEN_LSB]              ; Check the LSB register     
	jz      .done                          ; If it is 0 then we have a 0 length packet
.start_send:
	mov     A, [X+DATA_LSB]
	push    A
IF SYSTEM_LARGE_MEMORY_MODEL
	mov     A, [X+DATA_MSB]
	mov     reg[IDX_PP], A
ENDIF
	pop     X
	
.loop: 
	mov		A, [X]
	mov     reg[PMA0_DR], A
	inc     X
	dec     [USB_APITemp]
	jnz     .loop

	RAM_SETPAGE_IDX2STK     
.done:
    mov     X, SP
	mov     A, [X+EP_NUM]
	mov     X, A
	RAM_SETPAGE_IDX >USB_EndpointAPIStatus
    mov     [X + USB_EndpointAPIStatus], NO_EVENT_PENDING ; Set the state
	M8C_SetBank1	
	mov     A, reg[X+TMP_DR0-1]           ; Get the value of the PMA start Address								
        M8C_DisableGInt
	mov     reg[X + PMA0_RA], A           ; Load it into EP PMA so pre-fetch occurs                                          
	M8C_SetBank0	
        M8C_EnableGInt

        push    X
        RAM_SETPAGE_IDX2STK		
    mov     X, SP
    mov         A, [X+EP_TYPE-1]
        pop             X

   ; Check that we aren't halted
        RAM_SETPAGE_IDX >USB_EndpointAPIStatus
    CMP     [X + USB_EndpointAPIStatus], NO_EVENT_ALLOWED  ; Get the state
    JZ      .no_exempt_exit

    MOV     [X + USB_EndpointAPIStatus], NO_EVENT_PENDING ; Set the state

	M8C_SetBank1	
    mov     reg[X + USB_EP1MODE-1], A ; Enable the endpoint
.no_exempt_exit:

	M8C_SetBank0	

.exit:
        pop             A              ; Clean up EP_TYPE
    RAM_EPILOGUE RAM_USE_CLASS_3
	RAM_EPILOGUE RAM_USE_CLASS_4
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_EnableOutEP and
;                                 USB_EnableOutISOCEP
;
;  DESCRIPTION:    This function enables an OUT endpoint.  It should not be
;                  called for an IN endpoint.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:      A contains the endpoint number
;
;  RETURNS:        None
;
;  SIDE EFFECTS: 
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16 
;    functions.
;
USB_EnableOutISOCEP:
_USB_EnableOutISOCEP:
        mov             X, USB_MODE_ISO_OUT
        push    X
        jmp             BodyEnableOut_USB
 USB_EnableOutEP:
_USB_EnableOutEP:
        mov             X, USB_MODE_ACK_OUT
        push    X
BodyEnableOut_USB:
    RAM_PROLOGUE RAM_USE_CLASS_3
    RAM_SETPAGE_IDX >USB_EndpointAPIStatus

    cmp     A, 0                       ; Can't enable EP0
    jz      .exit                      ; Bail out
    cmp     A, (USB_MAX_EP_NUMBER + 1) ; Range check
    jnc     .exit                      ; Bail out
; Flow here to enable an endpoint        
    mov     X, A                       ; Endpoint number is the index

    ; Check that we aren't halted
    CMP     [X + USB_EndpointAPIStatus], NO_EVENT_ALLOWED  
    JZ      .exit

    push    X
    mov     [X+USB_EndpointAPIStatus], NO_EVENT_PENDING ; For the API
	mov     A, X
	asl     A
	mov     X, A
	mov     reg[X+EP1_CNT1-1], 64 
	M8C_SetBank1
	pop     X
    mov     A, reg[X+TMP_DR0-1]
	mov     reg[X+PMA0_WA], A
    mov     A, reg[X+USB_EP1MODE-1]    ; Unlock the mode register
    pop         A

    mov     reg[X+USB_EP1MODE-1], A    ; Enable the endpoint
    M8C_SetBank0
    jmp         .DoneEnableOut
; Jump or flow here for a common exit
.exit:
        pop             A
.DoneEnableOut:
    RAM_EPILOGUE RAM_USE_CLASS_3
    ret                                ; All done
.ENDSECTION

;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_DisableEP
;
;  DESCRIPTION:    This function disables an OUT endpoint.  It should not be
;                  called for an IN endpoint.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:	  A the endpoint number
;
;  RETURNS:		  none
;
;  SIDE EFFECTS: 
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16 
;    functions.
;
.SECTION
 USB_DisableOutEP:
_USB_DisableOutEP:
    cmp     A, 0                       ; Can't disable EP0
    jz      .exit                      ; Bail out
    cmp     A, (USB_MAX_EP_NUMBER + 1) ; Range check
    jnc     .exit                      ; Bail out
; Flow here to disable an endpoint        
    mov     X, A                       ; Endpoint number is the index
    M8C_SetBank1
    mov     A, reg[X+USB_EP1MODE-1]    ; Unlock the mode register
    mov     reg[X+USB_EP1MODE-1], USB_MODE_NAK_OUT ; Disable the endpoint
    M8C_SetBank0
; Jump or flow here for a common exit
.exit:
    ret                                ; All done
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_Force
;
;  DESCRIPTION:    Force the J/K/SE0 State of D+/D-
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:     A: USB_FORCE_J
;                    USB_FORCE_K
;                    USB_FORCE_SE0
;                    USB_FORCE_NONE
;
;  RETURNS:       Nothing
;
;  SIDE EFFECTS: 
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USB_Force:
_USB_Force:
    mov    reg[USB_USBIO_CR0], A
    ret                                ; Exit
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_bReadOutEP
;
;  DESCRIPTION:    This function reads the data from the USB Out endpoint
;                  and loads it into the specified buffer.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;     [SP-7] MSB of Count to read
;     [SP-6] LSB of Count to read
;     [SP-5] MSB of data array address to put data in
;     [SP-4] LSB of data array address to put data in
;     [SP-3] Endpoint Number
;
;  RETURNS:
;     none
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
;    Currently only the page pointer registers listed below are modified:
;          CUR_PP
;          IDX_PP
;
EP_NUMR:     equ -3			 ; Endpoint Number
DATA_LSBR:   equ -4           ; MSB pointer of data
DATA_MSBR:   equ -5           ; LSB pointer of data
CNTLEN_LSBR: equ -6           ; Length of data to send
CNTLEN_MSBR: equ -7

 USB_bReadOutEP:
_USB_bReadOutEP:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_PROLOGUE RAM_USE_CLASS_3
	RAM_SETPAGE_CUR >USB_bCurrentDevice   ; Set the CUR_PP to the right page
    RAM_SETPAGE_IDX2STK    
	mov     X, SP
	mov     A, [X+EP_NUMR]
	CMP     A, USB_MAX_EP_NUMBER+1        ; Range check
    JNC     .exit                      ; Bail out

    ;Get the count value passed
	mov     A, [X+CNTLEN_MSBR]            ; Get the MSB of the Count	
	and     A, 0x01                       ; Mask off the count bit
    mov     [USB_APITemp], A           ; Save the count
	mov     A, [X+CNTLEN_LSBR]            ; Get the LSB of the Count
	mov     [USB_APITemp+1], A            ; Save the count
	
    ;Determine which is smaller the requested data or the available data
	mov     A, [X+EP_NUMR]                 ; Get the Endpoint number 					
	asl     A                              ; Double the ep number for proper cnt access
	mov     X, A                           ; Make it into an index
	mov     A, reg[X+USB_EP1CNT1 - 2]      ; Get the Real count MSB
	and     A, 0x01                        ; Mask off the LSB
	cmp     A, [USB_APITemp]               ; Are they equal
	jz      .MSBEqual                      ; If they are check if they are 1
	jc      .CountDetermined               ;If the requested count is smaller use it 
	mov     [USB_APITemp], A               ; Else use the actual
	mov     A, reg[X+USB_EP1CNT1 - 1]      ; Get the Real count LSB
	mov     [USB_APITemp + 1], A           ; Else use the actual
    jmp     .CountDetermined
.MSBEqual:
    mov     A, [USB_APITemp]
    jz      .CheckLSB
    mov     [USB_APITemp + 1], 0
    jmp 	.CountDetermined
.CheckLSB:
	mov     A, reg[X+USB_EP1CNT1 - 1]      ; Get the Real count LSB
	cmp     A, [USB_APITemp+1]             ; Are they equal
	jz      .CountDetermined               ; If they are check if they are 1
	jnc      .CountDetermined              ;If the requested count is smaller use it 
	mov     [USB_APITemp+1], A             ; Else use the actual
.CountDetermined:

; First we need to determine where within the PMA the EP Start Address is
	mov     X, SP                          ; Get the Stack Pointer
	mov     A, [X+EP_NUMR]                 ; Get the Endpoint number
	mov     X, A                           ; Use the EP number as an index
	mov     A, reg[X+TMP_DR0-1]            ; Get the address of ep from tmp register 
	M8C_SetBank1
	M8C_DisableGInt	     ; bug 11658
	mov     reg[PMA0_RA], A                ; Set the Read pointer of our pma to ep space
	M8C_EnableGInt		 ; bug 11658
	M8C_SetBank0

; Now we are ready to start moving data
	and     [USB_APITemp], 0x01            ; Mask off the MSB bit
	jnz     .start_send	                   ; If it is high then we have 256 bytes
	mov     A, [USB_APITemp+1]             ; Check the LSB register
	jz      .done                          ; If it is 0 then we have a 0 length packet

.start_send:
    mov     X, SP
	mov     A, [X+DATA_LSBR]               ; Get the LSB of the pointer
	push    A                              ; save on stack
IF SYSTEM_LARGE_MEMORY_MODEL
	mov     A, [X+DATA_MSBR]               ; Get the MSB of the pointer
	mov     reg[IDX_PP], A                 ; Use as value for IDX_PP
ENDIF
	pop     X                              ; Get the LSB again

        ;;
        ;; 24Mhz read PMA workaround (kvn)
        ;;
        M8C_SetBank1
        mov A, reg[OSC_CR0]
        push A
        and A, 0xf8 ;clear the clock bits (briefly chg the cpu_clk to 3Mhz)
        or A, 0x02 ;will set clk to 12Mhz
        mov reg[OSC_CR0],A ;clk is now set at 12Mhz
        M8C_SetBank0

.loop: 
	mov     A, reg[PMA0_DR]                ; Get the data from the PMA space
	mov		[X], A                            ; save it in data array
	inc     X                              ; increment the pointer
	dec     [USB_APITemp+1]                ; decrement the counter
	jnz     .loop                          ; wait for count to zero out

        ;;
        ;; 24Mhz read PMA workaround (back to previous clock speed (kvn)
        ;;
        pop A ;recover previous reg[OSC_CR0] value
        M8C_SetBank1
        mov reg[OSC_CR0],A ;clk is now set at previous value (probably 24Mhz)
        M8C_SetBank0
        ;;
        ;; end 24Mhz read PMA workaround (kvn)
        ;;
	
	RAM_SETPAGE_IDX2STK     
    mov     X, SP
    mov     A, [X+EP_NUMR]
	asl     A
	mov     X, A
    mov     A, reg[X+USB_EP1CNT1 - 1]   ; Get the Real count LSB
	sub     A, 2
.done:
.exit:
    RAM_EPILOGUE RAM_USE_CLASS_3
	RAM_EPILOGUE RAM_USE_CLASS_4
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_bGetEPAckState
;
;  DESCRIPTION:   Returns whether the ACK bit of EP has been set for 
;                 an endpoint
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:     A is the Endpoint Number
;
;  RETURNS:       A is 0 if ACK bit is not set and non-zero if it is
;
;  SIDE EFFECTS: 
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USB_bGetEPAckState:
_USB_bGetEPAckState:
    mov    X, A
	M8C_SetBank1
    mov    A, reg[X + USB_EP1MODE-1]
	M8C_SetBank0
    and    A, 0x10
    ret                                ; Exit
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_SetPowerStatus
;
;  DESCRIPTION:    Set The Current Power status.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:      A contains the power status
;
;  RETURNS:        None
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USB_SetPowerStatus:
_USB_SetPowerStatus:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_SETPAGE_CUR >USB_DeviceStatus
    cmp  A, 0
    jz .bus_powered
    or   [USB_DeviceStatus], USB_DEVICE_STATUS_SELF_POWERED
    jmp  .done
.bus_powered:
    and  [USB_DeviceStatus], ~USB_DEVICE_STATUS_SELF_POWERED
.done:
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret                                ; All done
.ENDSECTION
